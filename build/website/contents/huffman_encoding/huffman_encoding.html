<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link rel=stylesheet href="/pygments.css" type="text/css">
    <link rel=stylesheet href="/styles/style.css" type="text/css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <title id="ttl"></title>
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
</head>
<body>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {inlineMath: [['$','$']]}
        });
    </script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
    <script>
        var bjs = {"gitbook": "3.x.x", "plugins": ["fontsettings", "mathjax@https://github.com/algorithm-archivists/plugin-mathjax", "bibtex-cite", "wordcount", "api-language-selector@https://github.com/algorithm-archivists/gitbook-plugin-api-language-selector.git", "include-codeblock", "ga", "bulk-redirect", "prism", "-highlight"], "lunr": {"maxIndexSize": 1000000000}, "pluginsConfig": {"mathjax": {"version": "2.6.1"}, "include-codeblock": {"fixlang": true, "unindent": true}, "bulk-redirect": {"basepath": "/", "redirectsFile": "redirects.json"}, "ga": {"token": "UA-118252470-1"}, "prism": {"lang": {"asm-x64": "nasm"}, "ignore": ["emojicode", "text"], "css": ["prismjs/themes/prism-tomorrow.css"]}, "api-language-selector": {"languages": [{"lang": "jl", "name": "Julia", "default": true}, {"lang": "bash", "name": "Bash"}, {"lang": "cs", "name": "C#"}, {"lang": "cpp", "name": "C++"}, {"lang": "c", "name": "C"}, {"lang": "c8", "name": "chip-8"}, {"lang": "py", "name": "Python"}, {"lang": "js", "name": "JavaScript"}, {"lang": "scratch", "name": "Scratch"}, {"lang": "hs", "name": "Haskell"}, {"lang": "rs", "name": "Rust"}, {"lang": "ml", "name": "OCaml"}, {"lang": "java", "name": "Java"}, {"lang": "clj", "name": "Clojure"}, {"lang": "elm", "name": "Elm"}, {"lang": "LabVIEW", "name": "LabVIEW"}, {"lang": "d", "name": "D"}, {"lang": "go", "name": "Go"}, {"lang": "swift", "name": "Swift"}, {"lang": "racket", "name": "Racket"}, {"lang": "m", "name": "Matlab"}, {"lang": "r", "name": "R"}, {"lang": "ti83b", "name": "TI-83 Basic"}, {"lang": "lua", "name": "Lua"}, {"lang": "crystal", "name": "Crystal"}, {"lang": "php", "name": "PHP"}, {"lang": "lisp", "name": "Common Lisp"}, {"lang": "nim", "name": "Nim"}, {"lang": "asm-x64", "name": "X86-64 Assembly"}, {"lang": "f90", "name": "Fortran90"}, {"lang": "factor", "name": "Factor"}, {"lang": "ws", "name": "Whitespace"}, {"lang": "scala", "name": "Scala"}, {"lang": "emojic", "name": "Emojicode"}, {"lang": "lolcode", "name": "LOLCODE"}, {"lang": "piet", "name": "Piet"}, {"lang": "ss", "name": "Scheme"}, {"lang": "ps1", "name": "PowerShell"}, {"lang": "v", "name": "Vlang"}, {"lang": "coffee", "name": "CoffeeScript"}, {"lang": "kotlin", "name": "Kotlin"}]}}};		    
        var lang = "jl";
        var langs = {};
        var langNames = bjs.pluginsConfig["api-language-selector"].languages;
        var translations = {
            "python": "Python",
            "bf": "Brainfuck",
            "st": "Smalltalk",
            "ruby": "Ruby",
            "kotlin": "Kotlin",
            "bash": "Bash",
            "haskell": "Haskell",
            "matlab": "Matlab",
            "javascript": "JavaScript"
        };
	
        function initLangs () {
            var samples = document.getElementsByClassName("code-section");
            for (var a = 0; a < samples.length; a++) {
                var sample = samples[a];
                var children = sample.children;
                for (var b = 0; b < children.length; b++)  {
                    var element = children[b];
                    langs[element.className] = true;
                };
            };
	    langs = Object.keys(langs);
	    if (langs.length == 1) {
		lang = langs[0];
	    }
            langNames.forEach(function(element) { translations[element.lang] = element.name });
        }
        function reload() {
            var samples = document.getElementsByClassName("code-section");
            for (var a = 0; a < samples.length; a++) {
                var sample = samples[a];
                var children = sample.children;
                for (var b = 0; b < children.length; b++)  {
                    var element = children[b];
                    if (element.className == lang) {
                        element.style.display = 'block';
                    } else {
                        element.style.display = 'none';
                    }
                };
            };
        };
        window.onload = () => {
            initLangs();
            reload();
            document.getElementById("name").innerText = pages[index];
            document.getElementById("ttl").innerText = pages[index];
            initLs();
        };
        var index = 33;
        var pages = [];
	var lsed = false;
				
        function flipLs () {
            var ls = document.getElementById("ls");
            var ls2 = document.getElementById("ls2");
            if (lsed) {
                ls.style.display = 'none';
                ls2.style.display = 'none';
            } else {
                ls.style.display = 'block';
                ls2.style.display = 'block';
            }
            lsed = !lsed
        }

	var funcs = {};
        function initLs () {
            if (langs.length === 0) {
                document.getElementById("flipper").remove();
            } else {
                var h1 = 0;
                var h2 = 0;
                for (var i = 0; i < langs.length; i++) {
                    let language = langs[i];
		    console.log(language);
		    var elem = document.createElement("p");
                    funcs[language] = {}
                    funcs[language] = () => {
                        lang = language;
                        reload();
                    };
                    elem.innerHTML = "<a onclick='funcs[\"" + language + "\"]()' href='#' class=ls-link>" + translations[language] + "</a>";
                    if (i % 2) {
                        h2 += 1
                        document.getElementById("ls2").appendChild(elem);
                    } else {
                        h1 += 1
                        document.getElementById("ls").appendChild(elem);
                    }
                }
                if (h1 > h2) {
                    var elem = document.createElement("p");
                    elem.innerHTML = "&nbsp;";
                    document.getElementById("ls2").appendChild(elem);
                } else if (h2 > h1) {
                    var elem = document.createElement("p");
                    elem.innerHTML = "&nbsp;";
                    document.getElementById("ls").appendChild(elem);
                }
                document.getElementById("ls").style.display = "none";
                document.getElementById("ls2").style.display = "none";
            }
        }
        function toggleSidenav () {
            $("#sidebar").toggleClass("hide");
            $("#content").toggleClass("on-sidebar");
            $("#navbar").toggleClass("no-sidebar");
        }
    </script>
    <div class="sidebar-wrapper" id="sidebar">
        
            <p>
                
                <a name="Algorithm Archive"></a>
                <a href="/index.html#Algorithm Archive">Algorithm Archive</a>
                <script>pages[0] = "Algorithm Archive"</script>
            </p>
        
            <p>
                
                <a name="Introduction"></a>
                <a href="/contents/introduction/introduction.html#Introduction">Introduction</a>
                <script>pages[1] = "Introduction"</script>
            </p>
        
            <p>
                
                <a name="How To Contribute"></a>
                <a href="/contents/how_to_contribute/how_to_contribute.html#How To Contribute">How To Contribute</a>
                <script>pages[2] = "How To Contribute"</script>
            </p>
        
            <p>
                
                <a name="Plotting"></a>
                <a href="/contents/plotting/plotting.html#Plotting">Plotting</a>
                <script>pages[3] = "Plotting"</script>
            </p>
        
            <p>
                
                <a name="Data Structures"></a>
                <a href="/contents/data_structures/data_structures.html#Data Structures">Data Structures</a>
                <script>pages[4] = "Data Structures"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Stacks and Queues"></a>
                <a href="/contents/stacks_and_queues/stacks_and_queues.html#Stacks and Queues">Stacks and Queues</a>
                <script>pages[5] = "Stacks and Queues"</script>
            </p>
        
            <p>
                
                <a name="Mathematical Background"></a>
                <a href="/contents/mathematical_background/mathematical_background.html#Mathematical Background">Mathematical Background</a>
                <script>pages[6] = "Mathematical Background"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Complexity Notation"></a>
                <a href="/contents/notation/notation.html#Complexity Notation">Complexity Notation</a>
                <script>pages[7] = "Complexity Notation"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Bit Logic"></a>
                <a href="/contents/bitlogic/bitlogic.html#Bit Logic">Bit Logic</a>
                <script>pages[8] = "Bit Logic"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Taylor Series"></a>
                <a href="/contents/taylor_series_expansion/taylor_series_expansion.html#Taylor Series">Taylor Series</a>
                <script>pages[9] = "Taylor Series"</script>
            </p>
        
            <p>
                
                <a name="Sorting and Searching"></a>
                <a href="/contents/sorting_and_searching/sorting_and_searching.html#Sorting and Searching">Sorting and Searching</a>
                <script>pages[10] = "Sorting and Searching"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Bubble Sort"></a>
                <a href="/contents/bubble_sort/bubble_sort.html#Bubble Sort">Bubble Sort</a>
                <script>pages[11] = "Bubble Sort"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Bogo Sort"></a>
                <a href="/contents/bogo_sort/bogo_sort.html#Bogo Sort">Bogo Sort</a>
                <script>pages[12] = "Bogo Sort"</script>
            </p>
        
            <p>
                
                <a name="Tree Traversal"></a>
                <a href="/contents/tree_traversal/tree_traversal.html#Tree Traversal">Tree Traversal</a>
                <script>pages[13] = "Tree Traversal"</script>
            </p>
        
            <p>
                
                <a name="Euclidean Algorithm"></a>
                <a href="/contents/euclidean_algorithm/euclidean_algorithm.html#Euclidean Algorithm">Euclidean Algorithm</a>
                <script>pages[14] = "Euclidean Algorithm"</script>
            </p>
        
            <p>
                
                <a name="Monte Carlo"></a>
                <a href="/contents/monte_carlo_integration/monte_carlo_integration.html#Monte Carlo">Monte Carlo</a>
                <script>pages[15] = "Monte Carlo"</script>
            </p>
        
            <p>
                
                <a name="Matrix Methods"></a>
                <a href="/contents/matrix_methods/matrix_methods.html#Matrix Methods">Matrix Methods</a>
                <script>pages[16] = "Matrix Methods"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Gaussian Elimination"></a>
                <a href="/contents/gaussian_elimination/gaussian_elimination.html#Gaussian Elimination">Gaussian Elimination</a>
                <script>pages[17] = "Gaussian Elimination"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Thomas Algorithm"></a>
                <a href="/contents/thomas_algorithm/thomas_algorithm.html#Thomas Algorithm">Thomas Algorithm</a>
                <script>pages[18] = "Thomas Algorithm"</script>
            </p>
        
            <p>
                
                <a name="Computational Geometry"></a>
                <a href="/contents/computational_geometry/computational_geometry.html#Computational Geometry">Computational Geometry</a>
                <script>pages[19] = "Computational Geometry"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Gift Wrapping"></a>
                <a href="/contents/gift_wrapping/gift_wrapping.html#Gift Wrapping">Gift Wrapping</a>
                <script>pages[20] = "Gift Wrapping"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                    &nbsp;
                
                <a name="Jarvis March"></a>
                <a href="/contents/jarvis_march/jarvis_march.html#Jarvis March">Jarvis March</a>
                <script>pages[21] = "Jarvis March"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                    &nbsp;
                
                <a name="Graham Scan"></a>
                <a href="/contents/graham_scan/graham_scan.html#Graham Scan">Graham Scan</a>
                <script>pages[22] = "Graham Scan"</script>
            </p>
        
            <p>
                
                <a name="FFT"></a>
                <a href="/contents/cooley_tukey/cooley_tukey.html#FFT">FFT</a>
                <script>pages[23] = "FFT"</script>
            </p>
        
            <p>
                
                <a name="Decision Problems"></a>
                <a href="/contents/decision_problems/decision_problems.html#Decision Problems">Decision Problems</a>
                <script>pages[24] = "Decision Problems"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Stable Marriage Problem"></a>
                <a href="/contents/stable_marriage_problem/stable_marriage_problem.html#Stable Marriage Problem">Stable Marriage Problem</a>
                <script>pages[25] = "Stable Marriage Problem"</script>
            </p>
        
            <p>
                
                <a name="Differential Equation Solvers"></a>
                <a href="/contents/differential_equations/differential_equations.html#Differential Equation Solvers">Differential Equation Solvers</a>
                <script>pages[26] = "Differential Equation Solvers"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Forward Euler Method"></a>
                <a href="/contents/forward_euler_method/forward_euler_method.html#Forward Euler Method">Forward Euler Method</a>
                <script>pages[27] = "Forward Euler Method"</script>
            </p>
        
            <p>
                
                <a name="Physics Solvers"></a>
                <a href="/contents/physics_solvers/physics_solvers.html#Physics Solvers">Physics Solvers</a>
                <script>pages[28] = "Physics Solvers"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Verlet Integration"></a>
                <a href="/contents/verlet_integration/verlet_integration.html#Verlet Integration">Verlet Integration</a>
                <script>pages[29] = "Verlet Integration"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Quantum Systems"></a>
                <a href="/contents/quantum_systems/quantum_systems.html#Quantum Systems">Quantum Systems</a>
                <script>pages[30] = "Quantum Systems"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                    &nbsp;
                
                <a name="Split-Operator Method"></a>
                <a href="/contents/split-operator_method/split-operator_method.html#Split-Operator Method">Split-Operator Method</a>
                <script>pages[31] = "Split-Operator Method"</script>
            </p>
        
            <p>
                
                <a name="Data Compression"></a>
                <a href="/contents/data_compression/data_compression.html#Data Compression">Data Compression</a>
                <script>pages[32] = "Data Compression"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Huffman Encoding"></a>
                <a href="/contents/huffman_encoding/huffman_encoding.html#Huffman Encoding">Huffman Encoding</a>
                <script>pages[33] = "Huffman Encoding"</script>
            </p>
        
            <p>
                
                <a name="Quantum Information"></a>
                <a href="/contents/quantum_information/quantum_information.html#Quantum Information">Quantum Information</a>
                <script>pages[34] = "Quantum Information"</script>
            </p>
        
        <hr>
    </div>
    <nav class="navbarrio" id=navbar>
        <ul class="navbarro">
            <li>
                <span onclick="toggleSidenav()">
                    <i class="fas fa-align-left"></i>
                </button>
            </li>
            <li>
                <span onclick="flipLs()" id=flipper>
                    <i class="fas fa-code"></i>
                    <div class=ls id=ls></div>
                    <div class=ls2 id=ls2></div>
                </span>
            </li>
            <li>
                <span id=name></span>
            </li>
        </ul>
    </nav>
    <div class="container-fluid on-sidebar" id="content">
        <h1>Huffman Encoding</h1>
<p>If there were ever a data compression method to take the world by storm, it would be Huffman encoding.
In fact, this was the method that got me into computational methods to begin with.
I distinctly remember sitting in my data compression class and talking about the great information theorist Claude Shannon and Robert Fano, when suddenly my professor introduced a new kid to the mix: David Huffman.
He managed to rip the heart out of the methods described by leaders of the field and create a data compression method that was easier to understand and implement, while also providing more robust results, and apparently this was all done for a school project!</p>
<p>It was in that moment, I knew I would never amount to anything.
I have since accepted that fact and moved on.</p>
<p>Huffman encoding follows from the problem described in the <a href="../data_compression/data_compression.html">Data Compression</a> section.
We have a string that we want to encode into bits.
Huffman encoding ensures that our encoded bitstring is as small as possible without losing any information.
Because it is both lossless and guarantees the smallest possible bit length, it outright replaces both Shannon and Shannon-Fano encoding in most cases, which is a little weird because the method was devised while Huffman was taking a course from Fano, himself!</p>
<p>The idea is somewhat straightforward in principle, but a little difficult to code in practice.
By creating a binary tree of the input alphabet, every branch can be provided a unique bit representation simply by assigning a binary value to each child and reading to a character in a leaf node if starting from the root node.</p>
<p>So now the question is: how do we create a binary tree?
Well, here we build it from the bottom up like so:</p>
<ol>
<li>Order all characters according to the frequency they appear in the input bitstring, with the most frequent character at the top of the list. Be sure to keep track of the frequencies, too!</li>
<li>Add the smallest two values together to create a new node with a new frequency.</li>
<li>Keep doing step 2 until the tree is complete.</li>
<li>Read the tree backwards from the root node and concatenate the final bitstring codeword. Keep all codewords and put them into your final set of codewords (sometimes called a codebook)</li>
<li>Encode your phrase with the codebook.</li>
</ol>
<p>And that's it.
Here's an image of what this might look like for the phrase <code>bibbity_bobbity</code>:</p>
<p>
    <img  class="center" src="res/huffman_tree.png" width="500" />
</p>

<p>This will create a codebook that looks like this:</p>
<table>
<thead>
<tr>
<th>Character</th>
<th>Bit Representation</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>b</em></td>
<td>0</td>
</tr>
<tr>
<td><em>i</em></td>
<td>100</td>
</tr>
<tr>
<td><em>t</em></td>
<td>101</td>
</tr>
<tr>
<td><em>y</em></td>
<td>110</td>
</tr>
<tr>
<td><em>o</em></td>
<td>1110</td>
</tr>
<tr>
<td>___</td>
<td>1111</td>
</tr>
</tbody>
</table>
<p>and <code>bibbity_bobbity</code> becomes <code>01000010010111011110111000100101110</code>.
As mentioned this uses the minimum number of bits possible for encoding.
The fact that this algorithm is both conceptually simple and provably useful is rather extraordinary to me and is why Huffman encoding will always hold a special place in my heart.</p>
<h2>Video Explanation</h2>
<p>Here is a quick video explanation for Huffman encoding:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/wHyUxTc2Ohk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<h2>Example Code</h2>
<p>In code, this can be a little tricky. It requires a method to continually sort the nodes as you add more and more nodes to the system.
The most straightforward way to do this in some languages is with a priority queue, but depending on the language, this might be more or less appropriate.
In addition, to read the tree backwards, some sort of <a href="../tree_traversal/tree_traversal.html">Depth First Search</a> needs to be implemented.
Whether you use a stack or straight-up recursion also depends on the language, but the recursive method is a little easier to understand in most cases.</p>
<div class=code-section>
<div class="jl">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="c1"># This is for the PriorityQueue</span>
<span class="n">using</span> <span class="n">DataStructures</span>

<span class="n">struct</span> <span class="n">Leaf</span>
    <span class="n">weight</span><span class="p">::</span><span class="n">Int64</span>
    <span class="n">key</span><span class="p">::</span><span class="n">Char</span>
<span class="n">end</span>

<span class="n">struct</span> <span class="n">Branch</span>
    <span class="n">right</span><span class="p">::</span><span class="n">Union</span><span class="p">{</span><span class="n">Leaf</span><span class="p">,</span> <span class="n">Branch</span><span class="p">}</span>
    <span class="n">left</span><span class="p">::</span><span class="n">Union</span><span class="p">{</span><span class="n">Leaf</span><span class="p">,</span> <span class="n">Branch</span><span class="p">}</span>
    <span class="n">weight</span><span class="p">::</span><span class="n">Int64</span>
<span class="n">end</span>

<span class="n">const</span> <span class="n">Node</span> <span class="o">=</span> <span class="n">Union</span><span class="p">{</span><span class="n">Leaf</span><span class="p">,</span> <span class="n">Branch</span><span class="p">}</span>
<span class="n">isbranch</span><span class="p">(</span><span class="n">branch</span><span class="p">::</span><span class="n">Branch</span><span class="p">)</span> <span class="o">=</span> <span class="n">true</span>
<span class="n">isbranch</span><span class="p">(</span><span class="n">other</span><span class="p">::</span><span class="n">T</span><span class="p">)</span> <span class="n">where</span> <span class="p">{</span><span class="n">T</span><span class="p">}</span> <span class="o">=</span> <span class="n">false</span>

<span class="n">function</span> <span class="n">codebook_recurse</span><span class="err">!</span><span class="p">(</span><span class="n">leaf</span><span class="p">::</span><span class="n">Leaf</span><span class="p">,</span> <span class="n">code</span><span class="p">::</span><span class="n">String</span><span class="p">,</span>
                          <span class="nb">dict</span><span class="p">::</span><span class="n">Dict</span><span class="p">{</span><span class="n">Char</span><span class="p">,</span><span class="n">String</span><span class="p">})</span>
    <span class="nb">dict</span><span class="p">[</span><span class="n">leaf</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span>
<span class="n">end</span>

<span class="n">function</span> <span class="n">codebook_recurse</span><span class="err">!</span><span class="p">(</span><span class="n">branch</span><span class="p">::</span><span class="n">Branch</span><span class="p">,</span> <span class="n">code</span><span class="p">::</span><span class="n">String</span><span class="p">,</span>
                          <span class="nb">dict</span><span class="p">::</span><span class="n">Dict</span><span class="p">{</span><span class="n">Char</span><span class="p">,</span><span class="n">String</span><span class="p">})</span>
    <span class="n">codebook_recurse</span><span class="err">!</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">string</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">),</span> <span class="nb">dict</span><span class="p">)</span>
    <span class="n">codebook_recurse</span><span class="err">!</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">string</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">),</span> <span class="nb">dict</span><span class="p">)</span>
<span class="n">end</span>

<span class="c1"># This will depth-first search through the tree</span>
<span class="c1"># to create bitstrings for each character.</span>
<span class="c1"># Note: Any depth-first search method will work</span>
<span class="c1"># This outputs encoding Dict to be used for encoding</span>
<span class="n">function</span> <span class="n">create_codebook</span><span class="p">(</span><span class="n">n</span><span class="p">::</span><span class="n">Node</span><span class="p">)</span>
    <span class="n">codebook</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">{</span><span class="n">Char</span><span class="p">,</span><span class="n">String</span><span class="p">}()</span>
    <span class="n">codebook_recurse</span><span class="err">!</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">codebook</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">codebook</span>
<span class="n">end</span>

<span class="c1"># This outputs huffman tree to generate dictionary for encoding</span>
<span class="n">function</span> <span class="n">create_tree</span><span class="p">(</span><span class="n">phrase</span><span class="p">::</span><span class="n">String</span><span class="p">)</span>

    <span class="c1"># creating weights</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phrase</span>
        <span class="n">temp_string</span> <span class="o">=</span> <span class="n">string</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">haskey</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">temp_string</span><span class="p">))</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">temp_string</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">temp_string</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">end</span>
    <span class="n">end</span>

    <span class="c1"># Creating all nodes to iterate through</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">{</span><span class="n">Node</span><span class="p">,</span> <span class="n">Int64</span><span class="p">}()</span>
    <span class="k">while</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">peek</span><span class="p">(</span><span class="n">weights</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">dequeue</span><span class="err">!</span><span class="p">(</span><span class="n">weights</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">temp_node</span> <span class="o">=</span> <span class="n">Leaf</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">enqueue</span><span class="err">!</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">temp_node</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
    <span class="n">end</span>

    <span class="k">while</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">node1</span> <span class="o">=</span> <span class="n">dequeue</span><span class="err">!</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">node2</span> <span class="o">=</span> <span class="n">dequeue</span><span class="err">!</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">temp_node</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">node1</span><span class="o">.</span><span class="n">weight</span> <span class="o">+</span> <span class="n">node2</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="n">enqueue</span><span class="err">!</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">temp_node</span><span class="p">,</span> <span class="n">temp_node</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
    <span class="n">end</span>

    <span class="n">huffman_tree</span> <span class="o">=</span> <span class="n">dequeue</span><span class="err">!</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">huffman_tree</span>

<span class="n">end</span>

<span class="n">function</span> <span class="n">encode</span><span class="p">(</span><span class="n">codebook</span><span class="p">::</span><span class="n">Dict</span><span class="p">{</span><span class="n">Char</span><span class="p">,</span> <span class="n">String</span><span class="p">},</span> <span class="n">phrase</span><span class="p">::</span><span class="n">String</span><span class="p">)</span>
    <span class="n">final_bitstring</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phrase</span>
        <span class="n">final_bitstring</span> <span class="o">=</span> <span class="n">final_bitstring</span> <span class="o">*</span> <span class="n">codebook</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">end</span>

    <span class="k">return</span> <span class="n">final_bitstring</span>
<span class="n">end</span>

<span class="n">function</span> <span class="n">decode</span><span class="p">(</span><span class="n">huffman_tree</span><span class="p">::</span><span class="n">Node</span><span class="p">,</span> <span class="n">bitstring</span><span class="p">::</span><span class="n">String</span><span class="p">)</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">huffman_tree</span>
    <span class="n">final_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bitstring</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span>
        <span class="k">else</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">right</span>
        <span class="n">end</span>
        <span class="k">if</span> <span class="p">(</span><span class="err">!</span><span class="n">isbranch</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
            <span class="n">final_string</span> <span class="o">=</span> <span class="n">final_string</span> <span class="o">*</span> <span class="n">string</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">huffman_tree</span>
        <span class="n">end</span>
    <span class="n">end</span>

    <span class="k">return</span> <span class="n">final_string</span>
<span class="n">end</span>

<span class="n">function</span> <span class="n">two_pass_huffman</span><span class="p">(</span><span class="n">phrase</span><span class="p">::</span><span class="n">String</span><span class="p">)</span>
    <span class="n">huffman_tree</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="n">phrase</span><span class="p">)</span>
    <span class="n">codebook</span> <span class="o">=</span> <span class="n">create_codebook</span><span class="p">(</span><span class="n">huffman_tree</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="n">codebook</span><span class="p">)</span>
    <span class="n">bitstring</span> <span class="o">=</span> <span class="n">encode</span><span class="p">(</span><span class="n">codebook</span><span class="p">,</span> <span class="n">phrase</span><span class="p">)</span>
    <span class="n">final_string</span> <span class="o">=</span> <span class="n">decode</span><span class="p">(</span><span class="n">huffman_tree</span><span class="p">,</span> <span class="n">bitstring</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="n">bitstring</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="n">final_string</span><span class="p">)</span>
<span class="n">end</span>

<span class="n">two_pass_huffman</span><span class="p">(</span><span class="s2">&quot;bibbity bobbity&quot;</span><span class="p">)</span>
</pre></div>

</div></p>
</div><div class="rs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">crate</span> <span class="n">itertools</span><span class="p">;</span>

<span class="n">use</span> <span class="n">std</span><span class="p">::</span><span class="nb">cmp</span><span class="p">::{</span><span class="n">Ord</span><span class="p">,</span> <span class="n">Ordering</span><span class="p">,</span> <span class="n">PartialOrd</span><span class="p">};</span>
<span class="n">use</span> <span class="n">std</span><span class="p">::</span><span class="n">collections</span><span class="p">::{</span><span class="n">BinaryHeap</span><span class="p">,</span> <span class="n">HashMap</span><span class="p">};</span>

<span class="n">use</span> <span class="n">itertools</span><span class="p">::</span><span class="n">Itertools</span><span class="p">;</span>

<span class="c1">#[derive(Debug)]</span>
<span class="n">enum</span> <span class="n">HuffmanTree</span> <span class="p">{</span>
    <span class="n">Branch</span> <span class="p">{</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">i32</span><span class="p">,</span>
        <span class="n">left</span><span class="p">:</span> <span class="n">Box</span><span class="o">&lt;</span><span class="n">HuffmanTree</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">right</span><span class="p">:</span> <span class="n">Box</span><span class="o">&lt;</span><span class="n">HuffmanTree</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">Leaf</span> <span class="p">{</span>
        <span class="n">count</span><span class="p">:</span> <span class="n">i32</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">char</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>

<span class="n">impl</span> <span class="n">PartialEq</span> <span class="k">for</span> <span class="n">HuffmanTree</span> <span class="p">{</span>
    <span class="n">fn</span> <span class="n">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">impl</span> <span class="n">Eq</span> <span class="k">for</span> <span class="n">HuffmanTree</span> <span class="p">{}</span>

<span class="n">impl</span> <span class="n">PartialOrd</span> <span class="k">for</span> <span class="n">HuffmanTree</span> <span class="p">{</span>
    <span class="n">fn</span> <span class="n">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">other</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">impl</span> <span class="n">Ord</span> <span class="k">for</span> <span class="n">HuffmanTree</span> <span class="p">{</span>
    <span class="n">fn</span> <span class="nb">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Ordering</span> <span class="p">{</span>
        <span class="n">other</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">#[derive(Debug)]</span>
<span class="n">struct</span> <span class="n">Codebook</span> <span class="p">{</span>
    <span class="n">codebook</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">char</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">tree</span><span class="p">:</span> <span class="n">HuffmanTree</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">impl</span> <span class="n">HuffmanTree</span> <span class="p">{</span>
    <span class="n">pub</span> <span class="n">fn</span> <span class="n">from</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="n">let</span> <span class="n">counts</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">chars</span><span class="p">()</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span><span class="n">HashMap</span><span class="p">::</span><span class="n">new</span><span class="p">(),</span> <span class="o">|</span><span class="n">mut</span> <span class="nb">map</span><span class="p">,</span> <span class="n">c</span><span class="o">|</span> <span class="p">{</span>
            <span class="o">*</span><span class="nb">map</span><span class="o">.</span><span class="n">entry</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">or_insert</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nb">map</span>
        <span class="p">});</span>
        <span class="n">let</span> <span class="n">mut</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">counts</span>
            <span class="o">.</span><span class="n">iter</span><span class="p">()</span>
            <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">)</span><span class="o">|</span> <span class="n">HuffmanTree</span><span class="p">::</span><span class="n">Leaf</span> <span class="p">{</span> <span class="n">value</span><span class="p">,</span> <span class="n">count</span> <span class="p">})</span>
            <span class="o">.</span><span class="n">collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">BinaryHeap</span><span class="o">&lt;</span><span class="n">HuffmanTree</span><span class="o">&gt;&gt;</span><span class="p">();</span>

        <span class="k">while</span> <span class="n">queue</span><span class="o">.</span><span class="n">len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="n">let</span> <span class="n">left</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="o">.</span><span class="n">unwrap</span><span class="p">();</span>
            <span class="n">let</span> <span class="n">right</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="o">.</span><span class="n">unwrap</span><span class="p">();</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">HuffmanTree</span><span class="p">::</span><span class="n">Branch</span> <span class="p">{</span>
                <span class="n">count</span><span class="p">:</span> <span class="n">left</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span>
                <span class="n">left</span><span class="p">:</span> <span class="n">Box</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">left</span><span class="p">),</span>
                <span class="n">right</span><span class="p">:</span> <span class="n">Box</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">right</span><span class="p">),</span>
            <span class="p">})</span>
        <span class="p">}</span>

        <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="o">.</span><span class="n">expect</span><span class="p">(</span><span class="s2">&quot;The Huffman tree has to have a root&quot;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">pub</span> <span class="n">fn</span> <span class="n">count</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">i32</span> <span class="p">{</span>
        <span class="n">match</span> <span class="o">*</span><span class="bp">self</span> <span class="p">{</span>
            <span class="n">HuffmanTree</span><span class="p">::</span><span class="n">Branch</span> <span class="p">{</span> <span class="n">count</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="o">=&gt;</span> <span class="n">count</span><span class="p">,</span>
            <span class="n">HuffmanTree</span><span class="p">::</span><span class="n">Leaf</span> <span class="p">{</span> <span class="n">count</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="o">=&gt;</span> <span class="n">count</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">pub</span> <span class="n">fn</span> <span class="n">make_codebook</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Codebook</span> <span class="p">{</span>
        <span class="n">let</span> <span class="n">mut</span> <span class="n">codebook</span> <span class="o">=</span> <span class="n">HashMap</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">mut</span> <span class="n">codebook</span><span class="p">);</span>
        <span class="n">Codebook</span> <span class="p">{</span>
            <span class="n">codebook</span><span class="p">,</span>
            <span class="n">tree</span><span class="p">:</span> <span class="bp">self</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">pub</span> <span class="n">fn</span> <span class="n">decode</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
        <span class="n">let</span> <span class="n">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="n">String</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span>
        <span class="n">let</span> <span class="n">mut</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="err">!</span><span class="nb">input</span><span class="p">[</span><span class="n">start</span><span class="o">..</span><span class="p">]</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode_dfs</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">input</span><span class="p">[</span><span class="n">start</span><span class="o">..</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">mut</span> <span class="n">result</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">result</span>
    <span class="p">}</span>

    <span class="n">fn</span> <span class="n">decode_dfs</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">mut</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">usize</span> <span class="p">{</span>
        <span class="n">let</span> <span class="n">current</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">chars</span><span class="p">()</span><span class="o">.</span><span class="n">next</span><span class="p">();</span>
        <span class="n">match</span> <span class="o">*</span><span class="bp">self</span> <span class="p">{</span>
            <span class="n">HuffmanTree</span><span class="p">::</span><span class="n">Branch</span> <span class="p">{</span> <span class="n">ref</span> <span class="n">left</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">if</span> <span class="n">current</span> <span class="o">==</span> <span class="n">Some</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="mi">1</span> <span class="o">+</span> <span class="n">left</span><span class="o">.</span><span class="n">decode_dfs</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">input</span><span class="p">[</span><span class="mf">1.</span><span class="o">.</span><span class="p">],</span> <span class="n">result</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="n">HuffmanTree</span><span class="p">::</span><span class="n">Branch</span> <span class="p">{</span> <span class="n">ref</span> <span class="n">right</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">if</span> <span class="n">current</span> <span class="o">==</span> <span class="n">Some</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="mi">1</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">decode_dfs</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">input</span><span class="p">[</span><span class="mf">1.</span><span class="o">.</span><span class="p">],</span> <span class="n">result</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="n">HuffmanTree</span><span class="p">::</span><span class="n">Leaf</span> <span class="p">{</span> <span class="n">value</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="n">result</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
                <span class="mi">0</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="o">=&gt;</span> <span class="n">panic</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;Unexpected end of input&quot;</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">fn</span> <span class="n">dfs</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">codebook</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">mut</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">char</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">match</span> <span class="o">*</span><span class="bp">self</span> <span class="p">{</span>
            <span class="n">HuffmanTree</span><span class="p">::</span><span class="n">Branch</span> <span class="p">{</span>
                <span class="n">ref</span> <span class="n">left</span><span class="p">,</span>
                <span class="n">ref</span> <span class="n">right</span><span class="p">,</span>
                <span class="o">..</span>
            <span class="p">}</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="n">left</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">code</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="n">codebook</span><span class="p">);</span>
                <span class="n">right</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">code</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="n">codebook</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">HuffmanTree</span><span class="p">::</span><span class="n">Leaf</span> <span class="p">{</span> <span class="n">value</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="n">codebook</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">impl</span> <span class="n">Codebook</span> <span class="p">{</span>
    <span class="n">fn</span> <span class="n">encode</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
        <span class="nb">input</span><span class="o">.</span><span class="n">chars</span><span class="p">()</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="o">&amp;</span><span class="bp">self</span><span class="o">.</span><span class="n">codebook</span><span class="p">[</span><span class="o">&amp;</span><span class="n">c</span><span class="p">])</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">fn</span> <span class="n">decode</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">let</span> <span class="nb">input</span> <span class="o">=</span> <span class="s2">&quot;bibbity bobbity&quot;</span><span class="p">;</span>

    <span class="n">let</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">HuffmanTree</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="nb">input</span><span class="p">);</span>
    <span class="n">let</span> <span class="n">codebook</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">make_codebook</span><span class="p">();</span>
    <span class="n">let</span> <span class="n">encoded</span> <span class="o">=</span> <span class="n">codebook</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="nb">input</span><span class="p">);</span>
    <span class="n">let</span> <span class="n">decoded</span> <span class="o">=</span> <span class="n">codebook</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">encoded</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">Uncomment</span> <span class="n">this</span> <span class="n">line</span> <span class="k">if</span> <span class="n">you</span> <span class="n">want</span> <span class="n">to</span> <span class="n">see</span> <span class="n">the</span> <span class="n">codebook</span><span class="o">/</span><span class="n">tree</span>
    <span class="o">//</span> <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;{:#?}&quot;</span><span class="p">,</span> <span class="n">codebook</span><span class="p">);</span>
    <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">encoded</span><span class="p">);</span>
    <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">decoded</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="c">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Made</span> <span class="n">by</span> <span class="n">Guston</span> <span class="ow">and</span> <span class="n">edited</span> <span class="n">by</span> <span class="n">Gathros</span>
<span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;stdlib.h&gt;</span>
<span class="c1">#include &lt;string.h&gt;</span>
<span class="c1">#include &lt;stdbool.h&gt;</span>

<span class="n">struct</span> <span class="n">tree</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
    <span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>

    <span class="nb">int</span> <span class="n">count</span><span class="p">;</span>
    <span class="n">char</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">struct</span> <span class="n">bitstring_builder</span> <span class="p">{</span>
    <span class="n">char</span> <span class="nb">str</span><span class="p">[</span><span class="mi">257</span><span class="p">];</span>
    <span class="nb">int</span> <span class="n">next_index</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">struct</span> <span class="n">codebook</span> <span class="p">{</span>
    <span class="n">char</span><span class="o">*</span> <span class="n">codes</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
<span class="p">};</span>

<span class="n">struct</span> <span class="n">heap</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="n">tree</span><span class="o">**</span> <span class="n">data</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">length</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">capacity</span><span class="p">;</span>
<span class="p">};</span>

<span class="nb">bool</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">const</span> <span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="err">!</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="err">!</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">struct</span> <span class="n">tree</span><span class="o">**</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">struct</span> <span class="n">tree</span><span class="o">**</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">lhs</span><span class="p">;</span>
    <span class="o">*</span><span class="n">lhs</span> <span class="o">=</span> <span class="o">*</span><span class="n">rhs</span><span class="p">;</span>
    <span class="o">*</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">/*</span> <span class="n">The</span> <span class="n">two</span> <span class="n">concat</span> <span class="n">functions</span> <span class="n">are</span> <span class="n">horribly</span> <span class="n">inefficient</span> <span class="o">*/</span>
<span class="n">void</span> <span class="n">concat</span><span class="p">(</span><span class="n">char</span><span class="o">**</span> <span class="n">dst</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">dst_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="o">*</span><span class="n">dst</span><span class="p">);</span>
    <span class="nb">int</span> <span class="n">src_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
    <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">src_len</span> <span class="o">+</span> <span class="n">dst_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">strcat</span><span class="p">(</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">concat_char</span><span class="p">(</span><span class="n">char</span><span class="o">**</span> <span class="n">dst</span><span class="p">,</span> <span class="n">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="nb">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="o">*</span><span class="n">dst</span><span class="p">);</span>
    <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="nb">len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">(</span><span class="o">*</span><span class="n">dst</span><span class="p">)[</span><span class="nb">len</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">(</span><span class="o">*</span><span class="n">dst</span><span class="p">)[</span><span class="nb">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">char</span><span class="o">*</span> <span class="n">duplicate</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">src</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
    <span class="n">char</span><span class="o">*</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">dst</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">heap_push</span><span class="p">(</span><span class="n">struct</span> <span class="n">heap</span><span class="o">*</span> <span class="n">heap</span><span class="p">,</span> <span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">==</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">heap</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">==</span> <span class="mi">0</span> <span class="err">?</span> <span class="mi">4</span> <span class="p">:</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">heap</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">*</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">tree</span><span class="o">*</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">heap</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

    <span class="nb">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">int</span> <span class="n">parent_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">parent_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">parent_index</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">parent_index</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">heap_pop</span><span class="p">(</span><span class="n">struct</span> <span class="n">heap</span><span class="o">*</span> <span class="n">heap</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="err">!</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="o">--</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">]);</span>

    <span class="nb">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="nb">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
        <span class="nb">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nb">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&amp;&amp;</span>
                <span class="n">heap</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&amp;&amp;</span>
                <span class="n">heap</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">target</span><span class="p">]);</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">heap_free</span><span class="p">(</span><span class="n">struct</span> <span class="n">heap</span><span class="o">*</span> <span class="n">heap</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">generate_tree</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">counts</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

    <span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="nb">str</span> <span class="o">!=</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">;</span> <span class="o">++</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">counts</span><span class="p">[(</span><span class="n">unsigned</span> <span class="n">char</span><span class="p">)</span><span class="o">*</span><span class="nb">str</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">struct</span> <span class="n">heap</span> <span class="n">heap</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span> <span class="o">/</span> <span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">tree</span><span class="p">));</span>
            <span class="n">tree</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">char</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
            <span class="n">tree</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">heap_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">,</span> <span class="n">tree</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">heap</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">leaf</span> <span class="o">=</span> <span class="n">heap_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span>
        <span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">tree</span><span class="p">));</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">leaf</span><span class="p">;</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
        <span class="n">heap_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">heap</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">left</span> <span class="o">=</span> <span class="n">heap_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span>
        <span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">right</span> <span class="o">=</span> <span class="n">heap_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span>
        <span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">branch</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">tree</span><span class="p">));</span>
        <span class="n">branch</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
        <span class="n">branch</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
        <span class="n">branch</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
        <span class="n">heap_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">,</span> <span class="n">branch</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="n">heap_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span>
    <span class="n">heap_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">tree_free</span><span class="p">(</span><span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="err">!</span><span class="n">tree</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">tree_free</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="n">tree_free</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">tree</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">codebook_recurse</span><span class="p">(</span><span class="n">const</span> <span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">tree</span><span class="p">,</span>
                        <span class="n">struct</span> <span class="n">bitstring_builder</span><span class="o">*</span> <span class="n">builder</span><span class="p">,</span>
                        <span class="n">struct</span> <span class="n">codebook</span><span class="o">*</span> <span class="n">codebook</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="err">!</span><span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">is_leaf</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">builder</span><span class="o">-&gt;</span><span class="nb">str</span><span class="p">[</span><span class="n">builder</span><span class="o">-&gt;</span><span class="n">next_index</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">;</span>
        <span class="n">codebook</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">[(</span><span class="n">unsigned</span> <span class="n">char</span><span class="p">)</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">duplicate</span><span class="p">(</span><span class="n">builder</span><span class="o">-&gt;</span><span class="nb">str</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">builder</span><span class="o">-&gt;</span><span class="nb">str</span><span class="p">[</span><span class="n">builder</span><span class="o">-&gt;</span><span class="n">next_index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">;</span>
    <span class="n">codebook_recurse</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">builder</span><span class="p">,</span> <span class="n">codebook</span><span class="p">);</span>
    <span class="n">builder</span><span class="o">-&gt;</span><span class="n">next_index</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">builder</span><span class="o">-&gt;</span><span class="nb">str</span><span class="p">[</span><span class="n">builder</span><span class="o">-&gt;</span><span class="n">next_index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span><span class="p">;</span>
    <span class="n">codebook_recurse</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">builder</span><span class="p">,</span> <span class="n">codebook</span><span class="p">);</span>
    <span class="n">builder</span><span class="o">-&gt;</span><span class="n">next_index</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">struct</span> <span class="n">codebook</span> <span class="n">generate_codebook</span><span class="p">(</span><span class="n">const</span> <span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="n">codebook</span> <span class="n">codebook</span> <span class="o">=</span> <span class="p">{</span> <span class="o">.</span><span class="n">codes</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">};</span>
    <span class="n">struct</span> <span class="n">bitstring_builder</span> <span class="n">builder</span> <span class="o">=</span> <span class="p">{</span> <span class="o">.</span><span class="n">str</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">},</span> <span class="o">.</span><span class="n">next_index</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">codebook_recurse</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">codebook</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">codebook</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">codebook_free</span><span class="p">(</span><span class="n">struct</span> <span class="n">codebook</span><span class="o">*</span> <span class="n">codebook</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">codebook</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">)</span> <span class="o">/</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">codebook</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">codebook</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">get_code</span><span class="p">(</span><span class="n">const</span> <span class="n">struct</span> <span class="n">codebook</span><span class="o">*</span> <span class="n">codebook</span><span class="p">,</span> <span class="n">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">codebook</span><span class="o">-&gt;</span><span class="n">codes</span><span class="p">[(</span><span class="n">unsigned</span> <span class="n">char</span><span class="p">)</span><span class="n">c</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">char</span><span class="o">*</span> <span class="n">encode</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="nb">input</span><span class="p">,</span> <span class="n">struct</span> <span class="n">tree</span><span class="o">**</span> <span class="n">huffman_tree</span><span class="p">,</span>
                <span class="n">struct</span> <span class="n">codebook</span><span class="o">*</span> <span class="n">codebook</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">huffman_tree</span> <span class="o">=</span> <span class="n">generate_tree</span><span class="p">(</span><span class="nb">input</span><span class="p">);</span>
    <span class="o">*</span><span class="n">codebook</span> <span class="o">=</span> <span class="n">generate_codebook</span><span class="p">(</span><span class="o">*</span><span class="n">huffman_tree</span><span class="p">);</span>

    <span class="n">char</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">duplicate</span><span class="p">(</span><span class="n">get_code</span><span class="p">(</span><span class="n">codebook</span><span class="p">,</span> <span class="o">*</span><span class="nb">input</span><span class="p">));</span>
    <span class="nb">int</span> <span class="n">result_length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="nb">int</span> <span class="n">result_capacity</span> <span class="o">=</span> <span class="n">result_length</span><span class="p">;</span>

    <span class="nb">input</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="nb">input</span><span class="p">;</span> <span class="o">++</span><span class="nb">input</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">concat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">,</span> <span class="n">get_code</span><span class="p">(</span><span class="n">codebook</span><span class="p">,</span> <span class="o">*</span><span class="nb">input</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">decode_recurse</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="nb">input</span><span class="p">,</span> <span class="n">const</span> <span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">tree</span><span class="p">,</span>
                            <span class="n">char</span><span class="o">**</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="err">!</span><span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">input</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">is_leaf</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">concat_char</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">input</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nb">input</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">decode_recurse</span><span class="p">(</span><span class="nb">input</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">decode_recurse</span><span class="p">(</span><span class="nb">input</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">char</span><span class="o">*</span> <span class="n">decode</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span><span class="o">*</span> <span class="nb">input</span><span class="p">,</span> <span class="n">const</span> <span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">char</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">do</span> <span class="p">{</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="n">decode_recurse</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="nb">input</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="n">tree</span><span class="o">*</span> <span class="n">tree</span><span class="p">;</span>
    <span class="n">struct</span> <span class="n">codebook</span> <span class="n">codebook</span><span class="p">;</span>

    <span class="n">char</span><span class="o">*</span> <span class="n">encoded</span> <span class="o">=</span> <span class="n">encode</span><span class="p">(</span><span class="s2">&quot;bibbity bobbity&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">codebook</span><span class="p">);</span>
    <span class="n">char</span><span class="o">*</span> <span class="n">decoded</span> <span class="o">=</span> <span class="n">decode</span><span class="p">(</span><span class="n">encoded</span><span class="p">,</span> <span class="n">tree</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Codebook:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">codebook</span><span class="o">.</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%c</span><span class="s2"> </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">char</span><span class="p">)</span><span class="n">i</span><span class="p">,</span> <span class="n">codebook</span><span class="o">.</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">encoded</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">decoded</span><span class="p">);</span>

    <span class="n">tree_free</span><span class="p">(</span><span class="n">tree</span><span class="p">);</span>
    <span class="n">codebook_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codebook</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">encoded</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">decoded</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="hs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">qualified</span> <span class="n">Data</span><span class="o">.</span><span class="n">Map</span> <span class="k">as</span> <span class="n">M</span>
<span class="kn">import</span>           <span class="nn">Data.List</span> <span class="p">(</span><span class="n">insert</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span>

<span class="n">data</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Leaf</span> <span class="n">Int</span> <span class="n">a</span>
            <span class="o">|</span> <span class="n">Node</span> <span class="n">Int</span> <span class="p">(</span><span class="n">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">Tree</span> <span class="n">a</span><span class="p">)</span>
                   <span class="n">deriving</span> <span class="p">(</span><span class="n">Show</span><span class="p">,</span> <span class="n">Eq</span><span class="p">)</span>

<span class="n">freq</span> <span class="p">::</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">Int</span>
<span class="n">freq</span> <span class="p">(</span><span class="n">Leaf</span> <span class="n">i</span> <span class="n">_</span><span class="p">)</span>   <span class="o">=</span> <span class="n">i</span>
<span class="n">freq</span> <span class="p">(</span><span class="n">Node</span> <span class="n">i</span> <span class="n">_</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span>

<span class="n">instance</span> <span class="p">(</span><span class="n">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">Ord</span> <span class="p">(</span><span class="n">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="n">where</span>
  <span class="n">compare</span> <span class="n">t1</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">compare</span> <span class="p">(</span><span class="n">freq</span> <span class="n">t1</span><span class="p">)</span> <span class="p">(</span><span class="n">freq</span> <span class="n">t2</span><span class="p">)</span>

<span class="n">getFrequencies</span> <span class="p">::</span> <span class="n">Ord</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[(</span><span class="n">Int</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span>
<span class="n">getFrequencies</span> <span class="o">=</span> <span class="n">toSortedList</span> <span class="o">.</span> <span class="n">M</span><span class="o">.</span><span class="n">fromListWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">.</span> <span class="n">flip</span> <span class="nb">zip</span> <span class="p">(</span><span class="n">repeat</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">where</span> <span class="n">toSortedList</span> <span class="o">=</span> <span class="n">sort</span> <span class="o">.</span> <span class="nb">map</span> <span class="n">swap</span> <span class="o">.</span> <span class="n">M</span><span class="o">.</span><span class="n">toList</span>
        <span class="n">swap</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

<span class="n">buildTree</span> <span class="p">::</span> <span class="p">(</span><span class="n">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="p">(</span><span class="n">Tree</span> <span class="n">a</span><span class="p">)</span>
<span class="n">buildTree</span> <span class="o">=</span> <span class="n">build</span> <span class="o">.</span> <span class="nb">map</span> <span class="p">(</span><span class="n">uncurry</span> <span class="n">Leaf</span><span class="p">)</span> <span class="o">.</span> <span class="n">getFrequencies</span>
  <span class="n">where</span> <span class="n">build</span> <span class="p">[]</span>         <span class="o">=</span> <span class="n">Nothing</span>
        <span class="n">build</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>        <span class="o">=</span> <span class="n">Just</span> <span class="n">t</span>
        <span class="n">build</span> <span class="p">(</span><span class="n">t1</span><span class="p">:</span><span class="n">t2</span><span class="p">:</span><span class="n">ts</span><span class="p">)</span> <span class="o">=</span> <span class="n">build</span> <span class="err">$</span> <span class="n">insert</span> <span class="p">(</span><span class="n">Node</span> <span class="p">(</span><span class="n">freq</span> <span class="n">t1</span> <span class="o">+</span> <span class="n">freq</span> <span class="n">t2</span><span class="p">)</span> <span class="n">t1</span> <span class="n">t2</span><span class="p">)</span> <span class="n">ts</span>

<span class="n">data</span> <span class="n">Bit</span> <span class="o">=</span> <span class="n">Zero</span> <span class="o">|</span> <span class="n">One</span>

<span class="n">instance</span> <span class="n">Show</span> <span class="n">Bit</span> <span class="n">where</span>
  <span class="n">show</span> <span class="n">Zero</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
  <span class="n">show</span> <span class="n">One</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span>

<span class="n">encode</span> <span class="p">::</span> <span class="p">(</span><span class="n">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">Maybe</span> <span class="p">(</span><span class="n">Tree</span> <span class="n">a</span><span class="p">),</span> <span class="p">[</span><span class="n">Bit</span><span class="p">])</span>
<span class="n">encode</span> <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
  <span class="n">where</span>
  <span class="n">tree</span> <span class="o">=</span> <span class="n">buildTree</span> <span class="n">s</span>
  <span class="n">msg</span> <span class="o">=</span> <span class="n">concatMap</span> <span class="p">(</span><span class="n">table</span> <span class="n">M</span><span class="o">.</span><span class="err">!</span><span class="p">)</span> <span class="n">s</span>
  <span class="n">table</span> <span class="o">=</span> <span class="n">case</span> <span class="n">tree</span> <span class="n">of</span>
    <span class="n">Nothing</span> <span class="o">-&gt;</span> <span class="n">M</span><span class="o">.</span><span class="n">empty</span>
    <span class="n">Just</span> <span class="n">t</span>  <span class="o">-&gt;</span> <span class="n">M</span><span class="o">.</span><span class="n">fromList</span> <span class="err">$</span> <span class="n">mkTable</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">[])</span>
  <span class="n">mkTable</span> <span class="p">(</span><span class="n">Leaf</span> <span class="n">_</span> <span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>     <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">reverse</span> <span class="n">p</span><span class="p">)]</span>
  <span class="n">mkTable</span> <span class="p">(</span><span class="n">Node</span> <span class="n">_</span> <span class="n">t1</span> <span class="n">t2</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="n">concatMap</span> <span class="n">mkTable</span> <span class="p">[(</span><span class="n">t1</span><span class="p">,</span>  <span class="n">Zero</span><span class="p">:</span><span class="n">p</span><span class="p">),</span> <span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">One</span><span class="p">:</span><span class="n">p</span><span class="p">)]</span>

<span class="n">decode</span> <span class="p">::</span> <span class="p">(</span><span class="n">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">Maybe</span> <span class="p">(</span><span class="n">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">Bit</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">decode</span> <span class="n">Nothing</span> <span class="n">_</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">decode</span> <span class="p">(</span><span class="n">Just</span> <span class="n">t</span><span class="p">)</span> <span class="n">m</span> <span class="o">=</span> <span class="n">path</span> <span class="n">t</span> <span class="n">m</span>
  <span class="n">where</span> <span class="n">path</span> <span class="p">(</span><span class="n">Leaf</span> <span class="n">_</span> <span class="n">a</span><span class="p">)</span> <span class="n">m</span>            <span class="o">=</span> <span class="n">a</span> <span class="p">:</span> <span class="n">path</span> <span class="n">t</span> <span class="n">m</span>
        <span class="n">path</span> <span class="p">(</span><span class="n">Node</span> <span class="n">_</span> <span class="n">t1</span> <span class="n">_</span><span class="p">)</span> <span class="p">(</span><span class="n">Zero</span><span class="p">:</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span> <span class="n">path</span> <span class="n">t1</span> <span class="n">m</span>
        <span class="n">path</span> <span class="p">(</span><span class="n">Node</span> <span class="n">_</span> <span class="n">_</span> <span class="n">t2</span><span class="p">)</span> <span class="p">(</span><span class="n">One</span><span class="p">:</span> <span class="n">m</span><span class="p">)</span>  <span class="o">=</span> <span class="n">path</span> <span class="n">t2</span> <span class="n">m</span>
        <span class="n">path</span> <span class="n">_</span> <span class="n">_</span>                     <span class="o">=</span> <span class="p">[]</span>

<span class="n">main</span> <span class="o">=</span> <span class="n">do</span>
  <span class="n">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;bibbity bobbity&quot;</span>
      <span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">encoded</span><span class="p">)</span> <span class="o">=</span> <span class="n">encode</span> <span class="n">msg</span>
      <span class="n">decoded</span> <span class="o">=</span> <span class="n">decode</span> <span class="n">tree</span> <span class="n">encoded</span>
  <span class="n">putStrLn</span> <span class="err">$</span> <span class="s2">&quot;Endoding </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">++</span> <span class="n">msg</span> <span class="o">++</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">: &quot;</span> <span class="o">++</span> <span class="n">concatMap</span> <span class="n">show</span> <span class="n">encoded</span>
  <span class="n">putStrLn</span> <span class="err">$</span> <span class="s2">&quot;Length: &quot;</span> <span class="o">++</span> <span class="p">(</span><span class="n">show</span> <span class="err">$</span> <span class="n">length</span> <span class="n">encoded</span><span class="p">)</span>
  <span class="n">putStrLn</span> <span class="err">$</span> <span class="s2">&quot;Decoding: &quot;</span> <span class="o">++</span> <span class="n">decoded</span>
</pre></div>

</div></p>
</div><div class="cs">
<h5>HuffmanCoding.cs</h5>
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">submitted</span> <span class="n">by</span> <span class="n">Julian</span> <span class="n">Schacher</span> <span class="p">(</span><span class="n">jspp</span><span class="p">),</span> <span class="n">thanks</span> <span class="n">to</span> <span class="n">gustorn</span> <span class="k">for</span> <span class="n">the</span> <span class="n">help</span>
<span class="n">using</span> <span class="n">System</span><span class="p">;</span>
<span class="n">using</span> <span class="n">System</span><span class="o">.</span><span class="n">Collections</span><span class="o">.</span><span class="n">Generic</span><span class="p">;</span>
<span class="n">using</span> <span class="n">System</span><span class="o">.</span><span class="n">Linq</span><span class="p">;</span>

<span class="n">namespace</span> <span class="n">HuffmanCoding</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="k">class</span> <span class="nc">EncodingResult</span>
    <span class="p">{</span>
        <span class="n">public</span> <span class="n">string</span> <span class="n">BitString</span> <span class="p">{</span> <span class="n">get</span><span class="p">;</span> <span class="nb">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">public</span> <span class="n">Dictionary</span><span class="o">&lt;</span><span class="n">char</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">Dictionary</span> <span class="p">{</span> <span class="n">get</span><span class="p">;</span> <span class="nb">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">public</span> <span class="n">HuffmanCoding</span><span class="o">.</span><span class="n">Node</span> <span class="n">Tree</span> <span class="p">{</span> <span class="n">get</span><span class="p">;</span> <span class="nb">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="n">public</span> <span class="n">EncodingResult</span><span class="p">(</span><span class="n">string</span> <span class="n">bitString</span><span class="p">,</span> <span class="n">Dictionary</span><span class="o">&lt;</span><span class="n">char</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">HuffmanCoding</span><span class="o">.</span><span class="n">Node</span> <span class="n">tree</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">this</span><span class="o">.</span><span class="n">BitString</span> <span class="o">=</span> <span class="n">bitString</span><span class="p">;</span>
            <span class="n">this</span><span class="o">.</span><span class="n">Dictionary</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">;</span>
            <span class="n">this</span><span class="o">.</span><span class="n">Tree</span> <span class="o">=</span> <span class="n">tree</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="k">class</span> <span class="nc">HuffmanCoding</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">The</span> <span class="n">Node</span> <span class="k">class</span> <span class="nc">used</span> <span class="k">for</span> <span class="n">the</span> <span class="n">Huffman</span> <span class="n">Tree</span><span class="o">.</span>
        <span class="n">public</span> <span class="k">class</span> <span class="nc">Node</span> <span class="p">:</span> <span class="n">IComparable</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span>
        <span class="p">{</span>
            <span class="n">public</span> <span class="n">Node</span> <span class="n">LeftChild</span> <span class="p">{</span> <span class="n">get</span><span class="p">;</span> <span class="nb">set</span><span class="p">;</span> <span class="p">}</span>
            <span class="n">public</span> <span class="n">Node</span> <span class="n">RightChild</span> <span class="p">{</span> <span class="n">get</span><span class="p">;</span> <span class="nb">set</span><span class="p">;</span> <span class="p">}</span>
            <span class="n">public</span> <span class="n">string</span> <span class="n">BitString</span> <span class="p">{</span> <span class="n">get</span><span class="p">;</span> <span class="nb">set</span><span class="p">;</span> <span class="p">}</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
            <span class="n">public</span> <span class="nb">int</span> <span class="n">Weight</span> <span class="p">{</span> <span class="n">get</span><span class="p">;</span> <span class="nb">set</span><span class="p">;</span> <span class="p">}</span>
            <span class="n">public</span> <span class="n">string</span> <span class="n">Key</span> <span class="p">{</span> <span class="n">get</span><span class="p">;</span> <span class="nb">set</span><span class="p">;</span> <span class="p">}</span>

            <span class="n">public</span> <span class="nb">bool</span> <span class="n">IsLeaf</span> <span class="o">=&gt;</span> <span class="n">LeftChild</span> <span class="o">==</span> <span class="n">null</span> <span class="o">&amp;&amp;</span> <span class="n">RightChild</span> <span class="o">==</span> <span class="n">null</span><span class="p">;</span>

            <span class="o">//</span> <span class="n">Creates</span> <span class="n">a</span> <span class="n">leaf</span><span class="o">.</span> <span class="n">So</span> <span class="n">just</span> <span class="n">a</span> <span class="n">node</span> <span class="ow">is</span> <span class="n">created</span> <span class="k">with</span> <span class="n">the</span> <span class="n">given</span> <span class="n">values</span><span class="o">.</span>
            <span class="n">public</span> <span class="n">static</span> <span class="n">Node</span> <span class="n">CreateLeaf</span><span class="p">(</span><span class="n">char</span> <span class="n">key</span><span class="p">,</span> <span class="nb">int</span> <span class="n">weight</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">ToString</span><span class="p">(),</span> <span class="n">weight</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span> <span class="n">null</span><span class="p">);</span>
            <span class="o">//</span> <span class="n">Creates</span> <span class="n">a</span> <span class="n">branch</span><span class="o">.</span> <span class="n">Here</span> <span class="n">a</span> <span class="n">node</span> <span class="ow">is</span> <span class="n">created</span> <span class="n">by</span> <span class="n">adding</span> <span class="n">the</span> <span class="n">keys</span> <span class="ow">and</span> <span class="n">weights</span> <span class="n">of</span> <span class="n">both</span> <span class="n">childs</span> <span class="n">together</span><span class="o">.</span>
            <span class="n">public</span> <span class="n">static</span> <span class="n">Node</span> <span class="n">CreateBranch</span><span class="p">(</span><span class="n">Node</span> <span class="n">leftChild</span><span class="p">,</span> <span class="n">Node</span> <span class="n">rightChild</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">leftChild</span><span class="o">.</span><span class="n">Key</span> <span class="o">+</span> <span class="n">rightChild</span><span class="o">.</span><span class="n">Key</span><span class="p">,</span> <span class="n">leftChild</span><span class="o">.</span><span class="n">Weight</span> <span class="o">+</span> <span class="n">rightChild</span><span class="o">.</span><span class="n">Weight</span><span class="p">,</span> <span class="n">leftChild</span><span class="p">,</span> <span class="n">rightChild</span><span class="p">);</span>
            <span class="n">private</span> <span class="n">Node</span><span class="p">(</span><span class="n">string</span> <span class="n">key</span><span class="p">,</span> <span class="nb">int</span> <span class="n">weight</span><span class="p">,</span> <span class="n">Node</span> <span class="n">leftChild</span><span class="p">,</span> <span class="n">Node</span> <span class="n">rightChild</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">this</span><span class="o">.</span><span class="n">Key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
                <span class="n">this</span><span class="o">.</span><span class="n">Weight</span> <span class="o">=</span>  <span class="n">weight</span><span class="p">;</span>
                <span class="n">this</span><span class="o">.</span><span class="n">LeftChild</span> <span class="o">=</span> <span class="n">leftChild</span><span class="p">;</span>
                <span class="n">this</span><span class="o">.</span><span class="n">RightChild</span> <span class="o">=</span> <span class="n">rightChild</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">public</span> <span class="nb">int</span> <span class="n">CompareTo</span><span class="p">(</span><span class="n">Node</span> <span class="n">other</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">this</span><span class="o">.</span><span class="n">Weight</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">Weight</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="o">//</span> <span class="n">Node</span> <span class="k">with</span> <span class="n">biggest</span> <span class="n">value</span> <span class="n">at</span> <span class="n">the</span> <span class="n">top</span><span class="o">.</span>
        <span class="k">class</span> <span class="nc">NodePriorityList</span>
        <span class="p">{</span>
            <span class="n">public</span> <span class="nb">int</span> <span class="n">Count</span> <span class="o">=&gt;</span> <span class="n">nodes</span><span class="o">.</span><span class="n">Count</span><span class="p">;</span>

            <span class="n">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">new</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>

            <span class="n">public</span> <span class="n">NodePriorityList</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
            <span class="n">public</span> <span class="n">NodePriorityList</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">givenNodes</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">this</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">givenNodes</span><span class="o">.</span><span class="n">ToList</span><span class="p">();</span>
                <span class="n">this</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">Sort</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="n">public</span> <span class="n">void</span> <span class="n">Add</span><span class="p">(</span><span class="n">Node</span> <span class="n">newNode</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">var</span> <span class="n">index</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">BinarySearch</span><span class="p">(</span><span class="n">newNode</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">this</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">Insert</span><span class="p">(</span><span class="o">~</span><span class="n">index</span><span class="p">,</span> <span class="n">newNode</span><span class="p">);</span>
                <span class="k">else</span>
                    <span class="n">this</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">Insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">newNode</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">public</span> <span class="n">Node</span> <span class="n">Pop</span><span class="p">()</span>
            <span class="p">{</span>
                <span class="n">var</span> <span class="n">result</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
                <span class="n">this</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">RemoveAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">public</span> <span class="n">EncodingResult</span> <span class="n">Encode</span><span class="p">(</span><span class="n">string</span> <span class="nb">input</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">var</span> <span class="n">root</span> <span class="o">=</span> <span class="n">CreateTree</span><span class="p">(</span><span class="nb">input</span><span class="p">);</span>
            <span class="n">var</span> <span class="n">dictionary</span> <span class="o">=</span> <span class="n">CreateDictionary</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
            <span class="n">var</span> <span class="n">bitString</span> <span class="o">=</span> <span class="n">CreateBitString</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">);</span>

            <span class="k">return</span> <span class="n">new</span> <span class="n">EncodingResult</span><span class="p">(</span><span class="n">bitString</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">public</span> <span class="n">string</span> <span class="n">Decode</span><span class="p">(</span><span class="n">EncodingResult</span> <span class="n">result</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">var</span> <span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
            <span class="n">Node</span> <span class="n">currentNode</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">Tree</span><span class="p">;</span>
            <span class="n">foreach</span> <span class="p">(</span><span class="n">var</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">BitString</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="o">//</span> <span class="n">Go</span> <span class="n">down</span> <span class="n">the</span> <span class="n">tree</span><span class="o">.</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
                    <span class="n">currentNode</span> <span class="o">=</span> <span class="n">currentNode</span><span class="o">.</span><span class="n">LeftChild</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">currentNode</span> <span class="o">=</span> <span class="n">currentNode</span><span class="o">.</span><span class="n">RightChild</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">currentNode</span><span class="o">.</span><span class="n">IsLeaf</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">output</span> <span class="o">+=</span> <span class="n">currentNode</span><span class="o">.</span><span class="n">Key</span><span class="p">;</span>
                    <span class="n">currentNode</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">Tree</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">private</span> <span class="n">Node</span> <span class="n">CreateTree</span><span class="p">(</span><span class="n">string</span> <span class="nb">input</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">List</span> <span class="n">of</span> <span class="nb">all</span> <span class="n">characters</span> <span class="ow">and</span> <span class="n">their</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">input</span> <span class="n">by</span> <span class="n">putting</span> <span class="n">them</span> <span class="n">into</span> <span class="n">nodes</span><span class="o">.</span>
            <span class="n">var</span> <span class="n">nodes</span> <span class="o">=</span> <span class="nb">input</span>
                <span class="o">.</span><span class="n">GroupBy</span><span class="p">(</span><span class="n">c</span> <span class="o">=&gt;</span> <span class="n">c</span><span class="p">)</span>
                <span class="o">.</span><span class="n">Select</span><span class="p">(</span><span class="n">n</span> <span class="o">=&gt;</span> <span class="n">Node</span><span class="o">.</span><span class="n">CreateLeaf</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">Key</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">Count</span><span class="p">()))</span>
                <span class="o">.</span><span class="n">ToList</span><span class="p">();</span>

            <span class="o">//</span> <span class="n">Convert</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">nodes</span> <span class="n">to</span> <span class="n">a</span> <span class="n">NodePriorityList</span><span class="o">.</span>
            <span class="n">var</span> <span class="n">nodePriorityList</span> <span class="o">=</span> <span class="n">new</span> <span class="n">NodePriorityList</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">Create</span> <span class="n">Tree</span><span class="o">.</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">nodePriorityList</span><span class="o">.</span><span class="n">Count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="o">//</span> <span class="n">Pop</span> <span class="n">the</span> <span class="n">two</span> <span class="n">nodes</span> <span class="k">with</span> <span class="n">the</span> <span class="n">smallest</span> <span class="n">weights</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">nodePriorityList</span> <span class="ow">and</span> <span class="n">create</span> <span class="n">a</span> <span class="n">parentNode</span> <span class="k">with</span> <span class="n">the</span> <span class="n">CreateBranch</span> <span class="n">method</span><span class="o">.</span> <span class="p">(</span><span class="n">This</span> <span class="n">method</span> <span class="n">adds</span> <span class="n">the</span> <span class="n">keys</span> <span class="ow">and</span> <span class="n">weights</span> <span class="n">of</span> <span class="n">the</span> <span class="n">childs</span> <span class="n">together</span><span class="o">.</span><span class="p">)</span>
                <span class="n">var</span> <span class="n">leftChild</span> <span class="o">=</span> <span class="n">nodePriorityList</span><span class="o">.</span><span class="n">Pop</span><span class="p">();</span>
                <span class="n">var</span> <span class="n">rightChild</span> <span class="o">=</span> <span class="n">nodePriorityList</span><span class="o">.</span><span class="n">Pop</span><span class="p">();</span>
                <span class="n">var</span> <span class="n">parentNode</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">CreateBranch</span><span class="p">(</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">rightChild</span><span class="p">);</span>

                <span class="n">nodePriorityList</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">parentNode</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">nodePriorityList</span><span class="o">.</span><span class="n">Pop</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">private</span> <span class="n">Dictionary</span><span class="o">&lt;</span><span class="n">char</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">CreateDictionary</span><span class="p">(</span><span class="n">Node</span> <span class="n">root</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">We</span><span class="s1">&#39;re using a string instead of a actual bits here, since it makes the code somewhat more readable and this is an educational example.</span>
            <span class="n">var</span> <span class="n">dictionary</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Dictionary</span><span class="o">&lt;</span><span class="n">char</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span><span class="p">();</span>
            <span class="n">CreateDictionary</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">dictionary</span><span class="p">;</span>

            <span class="n">void</span> <span class="n">CreateDictionary</span><span class="p">(</span><span class="n">Node</span> <span class="n">node</span><span class="p">,</span> <span class="n">string</span> <span class="n">bitString</span><span class="p">,</span> <span class="n">Dictionary</span><span class="o">&lt;</span><span class="n">char</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">localDictionary</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">IsLeaf</span><span class="p">)</span>
                    <span class="n">localDictionary</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">Key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bitString</span><span class="p">);</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">LeftChild</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span>
                        <span class="n">CreateDictionary</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">LeftChild</span><span class="p">,</span> <span class="n">bitString</span> <span class="o">+</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">localDictionary</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">RightChild</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span>
                        <span class="n">CreateDictionary</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">RightChild</span><span class="p">,</span> <span class="n">bitString</span> <span class="o">+</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="n">localDictionary</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="n">private</span> <span class="n">string</span> <span class="n">CreateBitString</span><span class="p">(</span><span class="n">string</span> <span class="nb">input</span><span class="p">,</span> <span class="n">Dictionary</span><span class="o">&lt;</span><span class="n">char</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">dictionary</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">We</span><span class="s1">&#39;re using a string right here. While no compression is achieved with a string, it&#39;</span><span class="n">s</span> <span class="n">the</span> <span class="n">easiest</span> <span class="n">way</span> <span class="n">to</span> <span class="n">display</span> <span class="n">what</span> <span class="n">the</span> <span class="n">compressed</span> <span class="n">result</span> <span class="n">looks</span> <span class="n">like</span><span class="o">.</span> <span class="n">Also</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">just</span> <span class="n">an</span> <span class="n">educational</span> <span class="n">example</span><span class="o">.</span>
            <span class="n">var</span> <span class="n">bitString</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
            <span class="n">foreach</span> <span class="p">(</span><span class="n">var</span> <span class="n">character</span> <span class="ow">in</span> <span class="nb">input</span><span class="p">)</span>
                <span class="n">bitString</span> <span class="o">+=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">character</span><span class="p">];</span>

            <span class="k">return</span> <span class="n">bitString</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
<h5>Program.cs</h5>
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">submitted</span> <span class="n">by</span> <span class="n">Julian</span> <span class="n">Schacher</span> <span class="p">(</span><span class="n">jspp</span><span class="p">),</span> <span class="n">thanks</span> <span class="n">to</span> <span class="n">gustorn</span> <span class="k">for</span> <span class="n">the</span> <span class="n">help</span>
<span class="n">using</span> <span class="n">System</span><span class="o">.</span><span class="n">Collections</span><span class="p">;</span>
<span class="n">using</span> <span class="n">System</span><span class="o">.</span><span class="n">Collections</span><span class="o">.</span><span class="n">Generic</span><span class="p">;</span>

<span class="n">namespace</span> <span class="n">HuffmanCoding</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="n">static</span> <span class="n">void</span> <span class="n">Main</span><span class="p">(</span><span class="n">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">var</span> <span class="n">huffmanCoding</span> <span class="o">=</span> <span class="n">new</span> <span class="n">HuffmanCoding</span><span class="p">();</span>

            <span class="n">var</span> <span class="n">result</span> <span class="o">=</span> <span class="n">huffmanCoding</span><span class="o">.</span><span class="n">Encode</span><span class="p">(</span><span class="s2">&quot;bibbity bobbity&quot;</span><span class="p">);</span>
            <span class="o">//</span> <span class="n">The</span> <span class="n">bitStrings</span> <span class="n">are</span> <span class="n">just</span> <span class="n">strings</span> <span class="ow">and</span> <span class="n">provide</span> <span class="n">no</span> <span class="n">compression</span><span class="o">.</span> <span class="n">Look</span> <span class="ow">in</span> <span class="n">HuffmanCoding</span><span class="o">.</span><span class="n">cs</span> <span class="k">for</span> <span class="n">explanation</span><span class="o">.</span>
            <span class="o">//</span> <span class="n">Print</span> <span class="n">dictionary</span><span class="o">.</span>
            <span class="n">foreach</span> <span class="p">(</span><span class="n">var</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">Dictionary</span><span class="p">)</span>
                <span class="n">System</span><span class="o">.</span><span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">$</span><span class="s2">&quot;</span><span class="si">{entry.Key}</span><span class="s2"> </span><span class="si">{entry.Value}</span><span class="s2">&quot;</span><span class="p">);</span>
            <span class="o">//</span> <span class="n">Print</span> <span class="n">BitString</span><span class="o">.</span>
            <span class="n">System</span><span class="o">.</span><span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">$</span><span class="s2">&quot;</span><span class="si">{result.BitString}</span><span class="s2"> count: </span><span class="si">{result.BitString.Length}</span><span class="s2">&quot;</span><span class="p">);</span>

            <span class="n">var</span> <span class="n">originalString</span> <span class="o">=</span> <span class="n">huffmanCoding</span><span class="o">.</span><span class="n">Decode</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
            <span class="n">System</span><span class="o">.</span><span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">originalString</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="lua">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="kd">local</span> <span class="kr">function</span> <span class="nf">frequency_array</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
  <span class="c1">-- Collect all frequency values into a dict</span>
  <span class="kd">local</span> <span class="n">map</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="kr">for</span> <span class="n">c</span> <span class="kr">in</span> <span class="n">str</span><span class="p">:</span><span class="n">gmatch</span><span class="s2">&quot;.&quot;</span> <span class="kr">do</span> <span class="c1">-- Iterate over each character in str</span>
    <span class="n">map</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">-- Increment map[c] (default 0) by 1</span>
  <span class="kr">end</span>
  
  <span class="c1">-- We have a dict of frequencies but we want it in a sorted list</span>
  <span class="c1">-- Dump each key value pair into an array</span>
  <span class="kd">local</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="kr">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="kr">in</span> <span class="nb">pairs</span><span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="kr">do</span>
    <span class="n">arr</span><span class="p">[</span><span class="o">#</span><span class="n">arr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">}</span>
  <span class="kr">end</span>
  <span class="nb">table.sort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="kr">function</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="kr">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="kr">end</span><span class="p">)</span> <span class="c1">-- Sort by frequency descending</span>
  <span class="kr">return</span> <span class="n">arr</span>
<span class="kr">end</span>

<span class="kr">function</span> <span class="nf">build_huffman_tree</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

  <span class="kr">if</span> <span class="o">#</span><span class="n">message</span> <span class="o">==</span> <span class="mi">0</span> <span class="kr">then</span> <span class="kr">return</span> <span class="kr">end</span>

  <span class="kd">local</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">frequency_array</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

  <span class="kr">while</span> <span class="o">#</span><span class="n">freq</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="kr">do</span> <span class="c1">-- Repeat until we have only 1 node</span>
    
    <span class="c1">-- Take two of the least frequent nodes</span>
    <span class="kd">local</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span> <span class="o">=</span> <span class="nb">table.remove</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="nb">table.remove</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
    
        <span class="c1">-- Group node values in first index, and sum of node frequencies in second</span>
    <span class="kd">local</span> <span class="n">node3</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="n">node1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">node2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">},</span> <span class="n">node1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">node2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">}</span>
  
    <span class="kd">local</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="kr">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="o">#</span><span class="n">freq</span> <span class="ow">and</span> <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">node3</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="kr">do</span> <span class="c1">-- Sorted insertion, faster than inserting then sorting again</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="kr">end</span>
    
    <span class="nb">table.insert</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">node3</span><span class="p">)</span>
  <span class="kr">end</span>
  
  <span class="kr">return</span> <span class="n">freq</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="c1">-- Return value of only element in freq array</span>
<span class="kr">end</span>

<span class="kd">local</span> <span class="kr">function</span> <span class="nf">_create_codebook</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">codebook</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span>
  <span class="kr">if</span> <span class="ow">not</span> <span class="n">node</span> <span class="kr">then</span>
    <span class="kr">return</span>
  <span class="kr">elseif</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;string&quot;</span> <span class="kr">then</span>
    <span class="n">codebook</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span> <span class="c1">-- if node is a leaf then add it to codebook</span>
  <span class="kr">else</span>
    <span class="n">_create_codebook</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">codebook</span><span class="p">,</span> <span class="n">code</span> <span class="o">..</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span> <span class="c1">-- Left side</span>
    <span class="n">_create_codebook</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">codebook</span><span class="p">,</span> <span class="n">code</span> <span class="o">..</span> <span class="s2">&quot;1&quot;</span><span class="p">)</span> <span class="c1">-- Right side</span>
  <span class="kr">end</span>
<span class="kr">end</span>

<span class="kr">function</span> <span class="nf">create_codebook</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
  <span class="kd">local</span> <span class="n">codebook</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">_create_codebook</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">codebook</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
  <span class="kr">return</span> <span class="n">codebook</span>
<span class="kr">end</span>

<span class="kr">function</span> <span class="nf">huffman_encode</span><span class="p">(</span><span class="n">codebook</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
  <span class="kd">local</span> <span class="n">encoded_chars</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="kr">for</span> <span class="n">c</span> <span class="kr">in</span> <span class="n">message</span><span class="p">:</span><span class="n">gmatch</span><span class="s2">&quot;.&quot;</span> <span class="kr">do</span> <span class="c1">-- Iterate over each character in message</span>
    <span class="n">encoded_chars</span><span class="p">[</span><span class="o">#</span><span class="n">encoded_chars</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">codebook</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
  <span class="kr">end</span>
  <span class="kr">return</span> <span class="nb">table.concat</span><span class="p">(</span><span class="n">encoded_chars</span><span class="p">)</span> <span class="c1">-- table.concat to avoid slow string bufferin</span>
<span class="kr">end</span>

<span class="kd">local</span> <span class="kr">function</span> <span class="nf">_huffman_decode</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">bitstring</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
  <span class="kr">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;string&quot;</span> <span class="kr">then</span>
    <span class="kr">return</span> <span class="n">node</span><span class="p">,</span> <span class="n">i</span> <span class="c1">-- If it&#39;s a leaf node then return the value along with the next bit to read</span>
  <span class="kr">end</span>
  <span class="kr">if</span> <span class="n">bitstring</span><span class="p">:</span><span class="n">sub</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;0&quot;</span> <span class="kr">then</span>
    <span class="kr">return</span> <span class="n">_huffman_decode</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bitstring</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">-- If it&#39;s 0 traverse down the left side</span>
  <span class="kr">elseif</span> <span class="n">bitstring</span><span class="p">:</span><span class="n">sub</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span> <span class="kr">then</span>
    <span class="kr">return</span> <span class="n">_huffman_decode</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bitstring</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">-- If it&#39;s 1 traverse down the right side</span>
  <span class="kr">end</span>
<span class="kr">end</span>

<span class="kr">function</span> <span class="nf">huffman_decode</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">bitstring</span><span class="p">)</span>
  <span class="c1">-- i is the current position in the bitstring, we can track which bit we are to look at next without using string.sub</span>
  <span class="kd">local</span> <span class="n">decoded_chars</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="p">{},</span> <span class="mi">1</span>
  <span class="kr">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="o">#</span><span class="n">bitstring</span> <span class="kr">do</span>
    <span class="n">decoded_chars</span><span class="p">[</span><span class="o">#</span><span class="n">decoded_chars</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">i</span> <span class="o">=</span> <span class="n">_huffman_decode</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">bitstring</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
  <span class="kr">end</span>
  
  <span class="kr">return</span> <span class="nb">table.concat</span><span class="p">(</span><span class="n">decoded_chars</span><span class="p">)</span>
<span class="kr">end</span>

<span class="kd">local</span> <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;bibbity_bobbity&quot;</span>

<span class="kd">local</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">build_huffman_tree</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
<span class="kd">local</span> <span class="n">codebook</span> <span class="o">=</span> <span class="n">create_codebook</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

<span class="kd">local</span> <span class="n">bitstring</span> <span class="o">=</span> <span class="n">huffman_encode</span><span class="p">(</span><span class="n">codebook</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Encoded: &quot;</span> <span class="o">..</span> <span class="n">bitstring</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Decoded: &quot;</span> <span class="o">..</span> <span class="n">huffman_decode</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">bitstring</span><span class="p">))</span>
</pre></div>

</div></p>
</div><div class="cpp">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="c1">#include &lt;algorithm&gt;</span>
<span class="c1">#include &lt;array&gt;</span>
<span class="c1">#include &lt;bitset&gt;</span>
<span class="c1">#include &lt;cassert&gt;</span>
<span class="c1">#include &lt;cctype&gt;</span>
<span class="c1">#include &lt;cstddef&gt;</span>
<span class="c1">#include &lt;limits&gt;</span>
<span class="c1">#include &lt;memory&gt;</span>
<span class="c1">#include &lt;string&gt;</span>
<span class="c1">#include &lt;utility&gt;</span>
<span class="c1">#include &lt;vector&gt;</span>

<span class="c1">#include &lt;iostream&gt;</span>

<span class="n">using</span> <span class="n">std</span><span class="p">::</span><span class="n">begin</span><span class="p">;</span>
<span class="n">using</span> <span class="n">std</span><span class="p">::</span><span class="n">end</span><span class="p">;</span>

<span class="n">namespace</span> <span class="n">huffman</span> <span class="p">{</span>

<span class="p">[[</span><span class="n">noreturn</span><span class="p">]]</span> <span class="n">inline</span> <span class="n">void</span> <span class="n">unreachable</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;this should never happen</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
  <span class="n">std</span><span class="p">::</span><span class="n">abort</span><span class="p">();</span>
<span class="p">}</span>

<span class="o">//</span> <span class="o">---</span> <span class="n">interface</span> <span class="o">---</span>
<span class="k">class</span> <span class="nc">codebook</span> <span class="p">{</span>
  <span class="n">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">frequency</span><span class="p">;</span>

    <span class="n">node</span><span class="p">(</span><span class="nb">int</span> <span class="n">freq</span><span class="p">)</span> <span class="p">:</span> <span class="n">frequency</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">virtual</span> <span class="o">~</span><span class="n">node</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="o">//</span> <span class="n">never</span> <span class="n">null</span>
  <span class="n">using</span> <span class="n">node_ptr</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">node</span> <span class="n">const</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">using</span> <span class="n">bitstring</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="o">//</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">flatmap</span> <span class="n">between</span> <span class="n">char</span> <span class="ow">and</span> <span class="n">a</span> <span class="n">bitstring</span>
  <span class="o">//</span> <span class="n">there</span> <span class="n">should</span> <span class="n">only</span> <span class="n">ever</span> <span class="n">be</span> <span class="n">one</span> <span class="n">character</span> <span class="k">with</span> <span class="n">a</span> <span class="n">given</span>
  <span class="o">//</span> <span class="n">value</span> <span class="n">at</span> <span class="nb">any</span> <span class="n">time</span><span class="o">.</span>
  <span class="n">using</span> <span class="n">encoder_t</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">char</span><span class="p">,</span> <span class="n">bitstring</span><span class="o">&gt;&gt;</span><span class="p">;</span>

  <span class="n">struct</span> <span class="n">leaf</span> <span class="n">final</span> <span class="p">:</span> <span class="n">node</span> <span class="p">{</span>
    <span class="n">char</span> <span class="n">key</span><span class="p">;</span>

    <span class="n">leaf</span><span class="p">(</span><span class="nb">int</span> <span class="n">freq</span><span class="p">,</span> <span class="n">char</span> <span class="n">key</span><span class="p">)</span> <span class="p">:</span> <span class="n">node</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="p">{}</span>
  <span class="p">};</span>

  <span class="n">struct</span> <span class="n">branch</span> <span class="n">final</span> <span class="p">:</span> <span class="n">node</span> <span class="p">{</span>
    <span class="n">node_ptr</span> <span class="n">lhs</span><span class="p">;</span>
    <span class="n">node_ptr</span> <span class="n">rhs</span><span class="p">;</span>

    <span class="n">branch</span><span class="p">(</span><span class="n">node_ptr</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">node_ptr</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="p">:</span> <span class="n">node</span><span class="p">(</span><span class="n">lhs</span><span class="o">-&gt;</span><span class="n">frequency</span> <span class="o">+</span> <span class="n">rhs</span><span class="o">-&gt;</span><span class="n">frequency</span><span class="p">),</span> <span class="n">lhs</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">)),</span>
          <span class="n">rhs</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">))</span> <span class="p">{}</span>
  <span class="p">};</span>

  <span class="o">//</span> <span class="n">this</span> <span class="n">allows</span> <span class="n">us</span> <span class="n">to</span> <span class="n">share</span> <span class="p">[</span><span class="n">codebook</span><span class="p">]</span><span class="n">s</span> <span class="n">among</span> <span class="n">encoded</span> <span class="n">strings</span>
  <span class="n">struct</span> <span class="n">data</span> <span class="p">{</span>
    <span class="n">node_ptr</span> <span class="n">decoder</span><span class="p">;</span>
    <span class="n">encoder_t</span> <span class="n">encoder</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">data</span> <span class="n">const</span><span class="o">&gt;</span> <span class="n">underlying_</span><span class="p">;</span>

<span class="n">public</span><span class="p">:</span>
  <span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
  <span class="n">codebook</span><span class="p">(</span><span class="n">Iter</span> <span class="n">const</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">const</span> <span class="n">last</span><span class="p">);</span>

  <span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
  <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span> <span class="n">encode</span><span class="p">(</span><span class="n">Iter</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">last</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>

  <span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
  <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">decode</span><span class="p">(</span><span class="n">Iter</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">last</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">struct</span> <span class="n">encoded_string</span> <span class="p">{</span>
  <span class="n">codebook</span> <span class="n">codes</span><span class="p">;</span>
  <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span> <span class="n">string</span><span class="p">;</span>

  <span class="n">explicit</span> <span class="n">encoded_string</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
      <span class="p">:</span> <span class="n">codes</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span> <span class="n">string</span><span class="p">(</span><span class="n">codes</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span> <span class="p">{}</span>

  <span class="n">encoded_string</span><span class="p">(</span><span class="n">codebook</span> <span class="n">codes</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
      <span class="p">:</span> <span class="n">codes</span><span class="p">(</span><span class="n">codes</span><span class="p">),</span> <span class="n">string</span><span class="p">(</span><span class="n">codes</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span> <span class="p">{}</span>

  <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">decoded</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">codes</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">string</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">string</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="o">//</span> <span class="o">---</span> <span class="n">implementation</span> <span class="o">---</span>
<span class="n">inline</span> <span class="n">codebook</span><span class="p">::</span><span class="n">node</span><span class="p">::</span><span class="o">~</span><span class="n">node</span><span class="p">()</span> <span class="p">{}</span>

<span class="n">inline</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span> <span class="n">with_new_bit</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span> <span class="n">bits</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">bits</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
<span class="n">codebook</span><span class="p">::</span><span class="n">codebook</span><span class="p">(</span><span class="n">Iter</span> <span class="n">const</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">const</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">struct</span> <span class="n">helper</span> <span class="p">{</span>
    <span class="n">static</span> <span class="n">node_ptr</span> <span class="n">make_decoder</span><span class="p">(</span><span class="n">Iter</span> <span class="n">const</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">const</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">//</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">part</span> <span class="n">of</span> <span class="n">the</span> <span class="n">function</span><span class="p">,</span> <span class="n">we</span> <span class="n">build</span> <span class="n">up</span> <span class="n">a</span> <span class="n">frequency</span> <span class="nb">list</span>
      <span class="o">//</span> <span class="nb">sorted</span> <span class="n">by</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">descending</span>
      <span class="n">auto</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">leaf</span><span class="o">&gt;</span><span class="p">();</span>

      <span class="n">std</span><span class="p">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">freq</span><span class="p">](</span><span class="n">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">auto</span> <span class="n">const</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">find_if</span><span class="p">(</span>
            <span class="n">begin</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="p">[</span><span class="n">c</span><span class="p">](</span><span class="n">auto</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">c</span><span class="p">;</span> <span class="p">});</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">(</span><span class="n">freq</span><span class="p">))</span> <span class="p">{</span>
          <span class="o">//</span> <span class="n">it</span><span class="s1">&#39;s already in the list</span>
          <span class="n">it</span><span class="o">-&gt;</span><span class="n">frequency</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="o">//</span> <span class="n">it</span><span class="s1">&#39;s not already in the list</span>
          <span class="n">freq</span><span class="o">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">});</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">freq</span><span class="o">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">throw</span> <span class="n">std</span><span class="p">::</span><span class="n">invalid_argument</span><span class="p">(</span><span class="s2">&quot;attempted to codebook an empty range&quot;</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="n">std</span><span class="p">::</span><span class="n">sort</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="p">[](</span><span class="n">auto</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">auto</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">lhs</span><span class="o">.</span><span class="n">frequency</span> <span class="o">&gt;</span> <span class="n">rhs</span><span class="o">.</span><span class="n">frequency</span><span class="p">;</span>
      <span class="p">});</span>

      <span class="n">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;&gt;</span><span class="p">();</span>
      <span class="n">std</span><span class="p">::</span><span class="n">transform</span><span class="p">(</span>
          <span class="n">begin</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">std</span><span class="p">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">ret</span><span class="p">),</span> <span class="p">[](</span><span class="n">auto</span> <span class="n">const</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">std</span><span class="p">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">leaf</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
          <span class="p">});</span>

      <span class="k">while</span> <span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">auto</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">back</span><span class="p">());</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="n">auto</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">back</span><span class="p">());</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">pop_back</span><span class="p">();</span>

        <span class="n">auto</span> <span class="n">new_node</span> <span class="o">=</span>
            <span class="n">std</span><span class="p">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">branch</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span> <span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">));</span>
        <span class="n">auto</span> <span class="n">const</span> <span class="n">new_freq</span> <span class="o">=</span> <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">frequency</span><span class="p">;</span>

        <span class="o">//</span> <span class="n">look</span> <span class="k">for</span> <span class="n">the</span> <span class="n">first</span> <span class="n">element</span> <span class="k">with</span> <span class="n">a</span> <span class="n">smaller</span> <span class="n">frequency</span>
        <span class="n">auto</span> <span class="n">const</span> <span class="n">it</span> <span class="o">=</span>
            <span class="n">std</span><span class="p">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">ret</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">ret</span><span class="p">),</span> <span class="p">[</span><span class="n">new_freq</span><span class="p">](</span><span class="n">auto</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">frequency</span> <span class="o">&lt;</span> <span class="n">new_freq</span><span class="p">;</span>
            <span class="p">});</span>
        <span class="o">//</span> <span class="ow">and</span> <span class="n">insert</span> <span class="n">the</span> <span class="n">new_node</span> <span class="n">before</span> <span class="n">that</span> <span class="n">element</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">new_node</span><span class="p">));</span>
        <span class="o">//</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">way</span><span class="p">,</span> <span class="n">we</span> <span class="n">keep</span> <span class="n">the</span> <span class="nb">list</span> <span class="nb">sorted</span> <span class="n">by</span> <span class="n">frequency</span>
      <span class="p">}</span>

      <span class="k">return</span> <span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">back</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">static</span> <span class="n">void</span>
    <span class="n">encoder_rec</span><span class="p">(</span><span class="n">node</span> <span class="n">const</span><span class="o">*</span> <span class="n">cur</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span> <span class="n">bits</span><span class="p">,</span> <span class="n">encoder_t</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">auto</span> <span class="n">l</span> <span class="o">=</span> <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="n">leaf</span> <span class="n">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">cur</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">out</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">bits</span><span class="p">)));</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="n">branch</span> <span class="n">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">cur</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">encoder_rec</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lhs</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">with_new_bit</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">out</span><span class="p">);</span>
        <span class="n">encoder_rec</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">rhs</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">with_new_bit</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">bits</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">out</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">unreachable</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">static</span> <span class="n">encoder_t</span> <span class="n">make_encoder</span><span class="p">(</span><span class="n">node</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">decoder</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">encoder_t</span><span class="p">();</span>

      <span class="n">encoder_rec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">decoder</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">ret</span><span class="p">);</span>

      <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="n">auto</span> <span class="n">decoder</span> <span class="o">=</span> <span class="n">helper</span><span class="p">::</span><span class="n">make_decoder</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
  <span class="n">auto</span> <span class="n">encoder</span> <span class="o">=</span> <span class="n">helper</span><span class="p">::</span><span class="n">make_encoder</span><span class="p">(</span><span class="o">*</span><span class="n">decoder</span><span class="p">);</span>
  <span class="n">underlying_</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">data</span> <span class="n">const</span><span class="o">&gt;</span><span class="p">(</span>
      <span class="n">data</span><span class="p">{</span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">decoder</span><span class="p">),</span> <span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">encoder</span><span class="p">)});</span>
<span class="p">}</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span> <span class="n">codebook</span><span class="p">::</span><span class="n">encode</span><span class="p">(</span><span class="n">Iter</span> <span class="n">const</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">const</span> <span class="n">last</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>

  <span class="n">auto</span><span class="o">&amp;</span> <span class="n">encoder</span> <span class="o">=</span> <span class="n">underlying_</span><span class="o">-&gt;</span><span class="n">encoder</span><span class="p">;</span>
  <span class="n">std</span><span class="p">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">encoder</span><span class="p">](</span><span class="n">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">auto</span> <span class="n">const</span> <span class="n">it</span> <span class="o">=</span>
        <span class="n">std</span><span class="p">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">encoder</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">encoder</span><span class="p">),</span> <span class="p">[</span><span class="n">c</span><span class="p">](</span><span class="n">auto</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">c</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">(</span><span class="n">encoder</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">auto</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">code</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
      <span class="n">std</span><span class="p">::</span><span class="n">copy</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">code</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">code</span><span class="p">),</span> <span class="n">std</span><span class="p">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">throw</span> <span class="n">std</span><span class="p">::</span><span class="n">invalid_argument</span><span class="p">(</span>
          <span class="s2">&quot;The range has a character which was not in the huffman set&quot;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">});</span>

  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
<span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">codebook</span><span class="p">::</span><span class="n">decode</span><span class="p">(</span><span class="n">Iter</span> <span class="n">const</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">const</span> <span class="n">last</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">ret</span><span class="p">;</span>

  <span class="n">node</span> <span class="n">const</span><span class="o">*</span> <span class="n">const</span> <span class="n">top</span> <span class="o">=</span> <span class="n">underlying_</span><span class="o">-&gt;</span><span class="n">decoder</span><span class="o">.</span><span class="n">get</span><span class="p">();</span>

  <span class="o">//</span> <span class="n">returns</span> <span class="n">a</span> <span class="n">pair</span><span class="p">:</span>
  <span class="o">//</span> <span class="n">the</span> <span class="n">second</span> <span class="n">member</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">decoded</span> <span class="n">character</span>
  <span class="o">//</span> <span class="n">the</span> <span class="n">first</span> <span class="n">member</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">place</span> <span class="n">we</span><span class="s1">&#39;ve gotten to in the range</span>
  <span class="o">//</span> <span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="p">,</span> <span class="k">if</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">an</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="ow">and</span> <span class="n">we</span> <span class="n">have</span>
  <span class="o">//</span> <span class="p">[</span><span class="n">it</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
  <span class="o">//</span> <span class="n">we</span> <span class="k">return</span> <span class="p">(</span><span class="n">it</span><span class="s1">&#39;, &#39;</span><span class="n">a</span><span class="s1">&#39;) such that</span>
  <span class="o">//</span> <span class="p">[</span><span class="n">it</span><span class="s1">&#39;, last) = { 1, 1, 0 }</span>
  <span class="n">auto</span> <span class="n">decode_single</span> <span class="o">=</span>
      <span class="p">[</span><span class="n">top</span><span class="p">](</span><span class="n">Iter</span> <span class="n">it</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">const</span> <span class="n">last</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Iter</span><span class="p">,</span> <span class="n">char</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">node</span> <span class="n">const</span><span class="o">*</span> <span class="n">current_node</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">auto</span> <span class="n">l</span> <span class="o">=</span> <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="n">leaf</span> <span class="n">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">current_node</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="p">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="n">branch</span> <span class="n">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">current_node</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">current_node</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">rhs</span><span class="o">.</span><span class="n">get</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">current_node</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">lhs</span><span class="o">.</span><span class="n">get</span><span class="p">();</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">unreachable</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">auto</span> <span class="n">l</span> <span class="o">=</span> <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="n">leaf</span> <span class="n">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">current_node</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="p">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">throw</span> <span class="n">std</span><span class="p">::</span><span class="n">invalid_argument</span><span class="p">(</span>
          <span class="s2">&quot;The range was not encoded with this huffman set&quot;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;)</span> <span class="p">{</span>
    <span class="n">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">decode_single</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">first</span><span class="p">;</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">second</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span> <span class="o">//</span> <span class="n">namespace</span> <span class="n">huffman</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">to_be_encoded</span> <span class="o">=</span> <span class="sa">R</span><span class="s2">&quot;(bibbity bobbity)&quot;</span><span class="p">;</span>

  <span class="n">auto</span> <span class="n">encoded</span> <span class="o">=</span> <span class="n">huffman</span><span class="p">::</span><span class="n">encoded_string</span><span class="p">(</span><span class="n">to_be_encoded</span><span class="p">);</span>

  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Encoded, the string looks like: &quot;</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="nb">bool</span> <span class="n">b</span> <span class="p">:</span> <span class="n">encoded</span><span class="o">.</span><span class="n">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">and decoded, the string looks like: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">encoded</span><span class="o">.</span><span class="n">decoded</span><span class="p">();</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">As opposed to the original, which is &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">to_be_encoded</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot; bits, the encoded has size &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">encoded</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="clj">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="p">;;</span> <span class="n">earthfail</span>
<span class="p">(</span><span class="n">ns</span> <span class="n">experiments</span><span class="o">.</span><span class="n">core</span><span class="p">)</span>

<span class="p">;;</span> <span class="n">get</span> <span class="n">a</span> <span class="n">vector</span> <span class="k">with</span> <span class="n">chars</span> <span class="ow">and</span> <span class="n">frequencies</span>

<span class="p">(</span><span class="n">defn</span> <span class="n">tree</span><span class="o">-</span><span class="n">string</span> <span class="p">[</span><span class="n">st</span><span class="p">]</span>
  <span class="s2">&quot;take a string st and return the huffmantree with the frequency of</span>
   <span class="n">each</span> <span class="n">character</span> <span class="n">included</span><span class="s2">&quot;</span>
  <span class="p">;;</span> <span class="n">vector</span> <span class="n">of</span> <span class="p">[</span><span class="n">character</span> <span class="n">frequency</span><span class="p">]</span> <span class="n">pair</span>
  <span class="p">;;</span> <span class="k">for</span> <span class="n">every</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">string</span><span class="p">,</span> <span class="n">added</span> <span class="n">it</span> <span class="n">to</span> <span class="nb">hash</span><span class="o">-</span><span class="nb">map</span>
  <span class="p">;;</span> <span class="k">with</span> <span class="n">value</span> <span class="n">one</span> <span class="k">if</span> <span class="n">it</span> <span class="n">doesn</span><span class="s1">&#39;t exist or increment its value</span>
  <span class="p">(</span><span class="k">def</span> <span class="nf">cf</span><span class="o">-</span><span class="n">vec</span> <span class="p">(</span><span class="n">vec</span>
               <span class="p">(</span><span class="n">reduce</span> <span class="p">(</span><span class="n">fn</span> <span class="p">[</span><span class="n">m</span> <span class="n">c</span><span class="p">]</span>
                         <span class="p">(</span><span class="n">assoc</span> <span class="n">m</span> <span class="n">c</span> <span class="p">(</span><span class="n">inc</span> <span class="p">(</span><span class="n">get</span> <span class="n">m</span> <span class="n">c</span> <span class="mi">0</span><span class="p">))))</span>
                       <span class="p">{}</span>
                       <span class="n">st</span><span class="p">)))</span>
  <span class="p">;;</span> <span class="n">make</span> <span class="n">a</span> <span class="nb">sorted</span> <span class="nb">list</span> <span class="k">with</span> <span class="n">nodes</span> <span class="k">with</span> <span class="n">bigger</span> <span class="n">frequencies</span> <span class="n">first</span>
  <span class="p">;;</span> <span class="n">take</span> <span class="n">the</span> <span class="n">last</span> <span class="n">two</span> <span class="n">which</span> <span class="n">will</span> <span class="n">help</span> <span class="ow">in</span> <span class="n">dividing</span> <span class="n">the</span> <span class="n">tree</span>
  <span class="p">;;</span> <span class="n">the</span> <span class="n">first</span> <span class="ow">and</span> <span class="n">last</span> <span class="n">elements</span> <span class="n">before</span> <span class="ow">and</span> <span class="n">after</span>
  <span class="p">;;</span> <span class="n">the</span> <span class="n">smallest</span> <span class="n">two</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">tree</span> <span class="n">shouldn</span><span class="s1">&#39;t change</span>
  <span class="p">(</span><span class="n">loop</span> <span class="p">[</span><span class="n">tree</span> <span class="p">(</span><span class="n">sort</span><span class="o">-</span><span class="n">by</span> <span class="n">last</span> <span class="o">&gt;</span> <span class="n">cf</span><span class="o">-</span><span class="n">vec</span><span class="p">)]</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">count</span> <span class="n">tree</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
      <span class="p">(</span><span class="n">first</span> <span class="n">tree</span><span class="p">)</span> <span class="p">;</span> <span class="n">only</span> <span class="n">of</span> <span class="n">tree</span> <span class="ow">is</span> <span class="n">one</span> <span class="n">node</span> <span class="ow">or</span> <span class="n">nil</span>
      <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="nb">sorted</span><span class="o">-</span><span class="n">tree</span> <span class="p">(</span><span class="n">sort</span><span class="o">-</span><span class="n">by</span> <span class="n">last</span> <span class="o">&gt;</span> <span class="n">tree</span><span class="p">)</span>
            <span class="n">mid</span> <span class="p">(</span><span class="n">take</span><span class="o">-</span><span class="n">last</span> <span class="mi">2</span> <span class="nb">sorted</span><span class="o">-</span><span class="n">tree</span><span class="p">)</span>
            <span class="nb">set</span><span class="o">-</span><span class="n">mid</span> <span class="p">(</span><span class="nb">set</span> <span class="n">mid</span><span class="p">)</span>
            <span class="n">func</span> <span class="p">(</span><span class="n">complement</span> <span class="p">(</span><span class="n">partial</span> <span class="n">contains</span><span class="err">?</span> <span class="nb">set</span><span class="o">-</span><span class="n">mid</span><span class="p">))</span>
            <span class="n">firsty</span> <span class="p">(</span><span class="n">take</span><span class="o">-</span><span class="k">while</span> <span class="n">func</span> <span class="n">tree</span><span class="p">)</span>
            <span class="p">[</span><span class="n">middle</span> <span class="n">lasty</span><span class="p">]</span> <span class="p">(</span><span class="n">split</span><span class="o">-</span><span class="n">at</span> <span class="mi">2</span>
                                     <span class="p">(</span><span class="n">drop</span><span class="o">-</span><span class="k">while</span> <span class="n">func</span> <span class="n">tree</span><span class="p">))]</span>
        <span class="p">(</span><span class="n">recur</span>
         <span class="p">(</span><span class="n">concat</span>
          <span class="n">firsty</span>
          <span class="p">;;</span> <span class="n">make</span> <span class="n">a</span> <span class="nb">list</span> <span class="k">with</span> <span class="n">the</span> <span class="n">two</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">one</span> <span class="nb">list</span> <span class="ow">and</span>
          <span class="p">;;</span> <span class="n">the</span> <span class="nb">sum</span> <span class="n">of</span> <span class="n">their</span> <span class="n">frequencies</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span>
          <span class="p">;;</span> <span class="s1">&#39;(((node1 f1) (node2 f2)) f1+f2)</span>
          <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">list</span> <span class="n">middle</span> <span class="p">(</span><span class="n">reduce</span> <span class="c1">#(+ %1 (last %2)) 0 middle)))</span>
          <span class="n">lasty</span><span class="p">))))))</span>

<span class="p">(</span><span class="n">defn</span> <span class="n">remove</span><span class="o">-</span><span class="n">freq</span> <span class="p">[</span><span class="n">tree</span><span class="p">]</span>
  <span class="s2">&quot;remove the frequencies in the huffmantree tree&quot;</span>
  <span class="p">(</span><span class="n">cond</span>
    <span class="p">(</span><span class="n">char</span><span class="err">?</span> <span class="n">tree</span><span class="p">)</span> <span class="n">tree</span>                 <span class="p">;</span> <span class="n">check</span> <span class="k">if</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">branch</span>
    <span class="p">;;</span> <span class="k">if</span> <span class="n">the</span> <span class="n">tree</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">node</span> <span class="ow">and</span> <span class="n">frequency</span> <span class="n">then</span> <span class="n">ignore</span> <span class="n">frequency</span>
    <span class="p">(</span><span class="n">integer</span><span class="err">?</span> <span class="p">(</span><span class="n">second</span> <span class="n">tree</span><span class="p">))</span> <span class="p">(</span><span class="n">remove</span><span class="o">-</span><span class="n">freq</span> <span class="p">(</span><span class="n">first</span> <span class="n">tree</span><span class="p">))</span> <span class="p">;</span><span class="n">remove</span> <span class="n">the</span> <span class="n">frequency</span>
    <span class="p">;;</span> <span class="k">if</span> <span class="n">the</span> <span class="n">tree</span> <span class="n">consists</span> <span class="n">of</span> <span class="n">two</span> <span class="n">nodes</span> <span class="n">then</span> <span class="n">apply</span> <span class="n">to</span> <span class="n">both</span> <span class="ow">and</span> <span class="n">combine</span>
    <span class="p">:</span><span class="k">else</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="n">remove</span><span class="o">-</span><span class="n">freq</span> <span class="p">(</span><span class="n">first</span> <span class="n">tree</span><span class="p">))</span>
                <span class="p">(</span><span class="n">remove</span><span class="o">-</span><span class="n">freq</span> <span class="p">(</span><span class="n">second</span> <span class="n">tree</span><span class="p">)))))</span>

<span class="p">(</span><span class="n">defn</span> <span class="nb">hash</span><span class="o">-</span><span class="n">tree</span> <span class="p">[</span><span class="n">tree</span><span class="p">]</span>
  <span class="s2">&quot;make a hashmap with code for each letter as key and the letter as</span>
  <span class="n">value</span><span class="s2">&quot;</span>
  <span class="p">(</span><span class="n">cond</span>
    <span class="p">(</span><span class="n">char</span><span class="err">?</span> <span class="n">tree</span><span class="p">)</span> <span class="p">{</span><span class="s2">&quot;&quot;</span> <span class="n">tree</span><span class="p">}</span>
    <span class="p">:</span><span class="k">else</span>
    <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">left</span><span class="o">-</span><span class="nb">map</span> <span class="p">(</span><span class="nb">hash</span><span class="o">-</span><span class="n">tree</span> <span class="p">(</span><span class="n">first</span> <span class="n">tree</span><span class="p">))</span>
          <span class="n">right</span><span class="o">-</span><span class="nb">map</span> <span class="p">(</span><span class="nb">hash</span><span class="o">-</span><span class="n">tree</span> <span class="p">(</span><span class="n">second</span> <span class="n">tree</span><span class="p">))</span>
          <span class="n">func</span> <span class="c1">#(apply hash-map         ; apply hash-map because</span>
                                        <span class="p">;</span> <span class="n">interleave</span> <span class="k">return</span> <span class="n">a</span> <span class="n">seq</span>
                       <span class="p">(</span><span class="n">interleave</span>
                        <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="n">partial</span> <span class="nb">str</span> <span class="o">%</span><span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="n">keys</span> <span class="o">%</span><span class="mi">1</span><span class="p">))</span> <span class="p">;</span><span class="n">add</span> <span class="mi">0</span> <span class="ow">or</span> <span class="mi">1</span>
                                        <span class="p">;</span><span class="n">to</span> <span class="n">the</span> <span class="n">start</span>
                                        <span class="p">;</span><span class="n">of</span> <span class="n">the</span> <span class="n">keys</span>
                        <span class="p">(</span><span class="n">vals</span> <span class="o">%</span><span class="mi">1</span><span class="p">)))]</span>
      <span class="p">;;</span> <span class="n">add</span> <span class="s2">&quot;0&quot;</span> <span class="n">to</span> <span class="n">the</span> <span class="n">keys</span> <span class="n">of</span> <span class="n">left</span> <span class="n">nodes</span> <span class="ow">and</span> <span class="s2">&quot;1&quot;</span> <span class="n">to</span> <span class="n">the</span> <span class="n">right</span> <span class="n">nodes</span>
      <span class="p">(</span><span class="n">merge</span> <span class="p">(</span><span class="n">func</span> <span class="n">left</span><span class="o">-</span><span class="nb">map</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span> <span class="p">(</span><span class="n">func</span> <span class="n">right</span><span class="o">-</span><span class="nb">map</span> <span class="s2">&quot;1&quot;</span><span class="p">)))))</span>


<span class="p">(</span><span class="n">defn</span> <span class="n">coder</span> <span class="p">[</span><span class="n">s</span> <span class="nb">hash</span><span class="o">-</span><span class="n">coder</span><span class="p">]</span>
  <span class="s2">&quot;take a string s and return a coded string&quot;</span>
  <span class="p">(</span><span class="n">apply</span> <span class="nb">str</span> <span class="p">(</span><span class="nb">map</span> <span class="nb">hash</span><span class="o">-</span><span class="n">coder</span> <span class="n">s</span><span class="p">)))</span>

<span class="p">(</span><span class="n">defn</span> <span class="n">decoder</span> <span class="p">[</span><span class="n">s</span> <span class="nb">hash</span><span class="o">-</span><span class="n">decoder</span><span class="p">]</span>
  <span class="s2">&quot;takes a string s and a hash-map hash-decoder and decode s&quot;</span>
  <span class="p">;;</span> <span class="n">code</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="n">hashmap</span> <span class="ow">is</span> <span class="k">for</span> <span class="n">storing</span> <span class="n">codes</span> <span class="n">untill</span> <span class="n">they</span> <span class="n">are</span>
  <span class="p">;;</span> <span class="n">complete</span> <span class="ow">and</span> <span class="n">can</span> <span class="n">be</span> <span class="n">decoded</span> <span class="k">with</span> <span class="n">the</span> <span class="n">decoder</span>
  <span class="p">(</span><span class="n">get</span> <span class="p">(</span><span class="n">reduce</span> <span class="p">(</span><span class="n">fn</span> <span class="p">[</span><span class="n">m</span> <span class="n">code</span><span class="p">]</span>             <span class="p">;</span> <span class="n">reduce</span> <span class="k">return</span> <span class="p">{:</span><span class="n">message</span>
                                        <span class="p">;</span> <span class="n">message</span><span class="p">,:</span><span class="n">code</span> <span class="n">_</span><span class="p">}</span>
                 <span class="p">(</span><span class="n">let</span> <span class="p">[</span><span class="n">new</span><span class="o">-</span><span class="n">code</span> <span class="p">(</span><span class="nb">str</span> <span class="p">(</span><span class="n">m</span> <span class="p">:</span><span class="n">code</span><span class="p">)</span> <span class="n">code</span><span class="p">)]</span>
                   <span class="p">(</span><span class="k">if</span><span class="o">-</span><span class="n">let</span>  <span class="p">[</span><span class="n">letter</span> <span class="p">(</span><span class="n">get</span> <span class="nb">hash</span><span class="o">-</span><span class="n">decoder</span> <span class="n">new</span><span class="o">-</span><span class="n">code</span><span class="p">)]</span>
                     <span class="p">;;</span> <span class="k">if</span> <span class="n">there</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">letter</span> <span class="n">then</span> <span class="n">add</span> <span class="n">it</span> <span class="n">to</span> <span class="p">:</span><span class="n">message</span>
                     <span class="p">;;</span> <span class="ow">and</span> <span class="n">revert</span> <span class="p">:</span><span class="n">code</span> <span class="n">to</span> <span class="n">empty</span>
                     <span class="p">(</span><span class="n">assoc</span> <span class="p">(</span><span class="n">update</span> <span class="n">m</span> <span class="p">:</span><span class="n">message</span> <span class="c1">#(str % letter))</span>
                            <span class="p">:</span><span class="n">code</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                     <span class="p">;;</span> <span class="k">if</span> <span class="n">there</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">a</span> <span class="n">letter</span> <span class="n">then</span> <span class="n">just</span> <span class="n">add</span> <span class="n">the</span>
                     <span class="p">;;</span> <span class="n">code</span> <span class="n">letter</span> <span class="n">to</span> <span class="n">the</span> <span class="p">:</span><span class="n">code</span>
                     <span class="p">(</span><span class="n">update</span> <span class="n">m</span> <span class="p">:</span><span class="n">code</span> <span class="c1">#(str % code)))))</span>
               <span class="p">{:</span><span class="n">message</span> <span class="s2">&quot;&quot;</span><span class="p">,:</span><span class="n">code</span> <span class="s2">&quot;&quot;</span><span class="p">}</span>
               <span class="n">s</span><span class="p">)</span>
       <span class="p">:</span><span class="n">message</span><span class="p">))</span>           <span class="p">;</span><span class="n">extract</span> <span class="p">:</span><span class="n">message</span>  <span class="n">value</span>
<span class="p">;;</span> <span class="o">----------------</span><span class="n">EXAMPLE</span><span class="o">----------------</span>
<span class="p">(</span><span class="k">def</span> <span class="nf">st</span> <span class="s2">&quot;(bibbity bobbity)&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="k">def</span> <span class="nf">hash</span><span class="o">-</span><span class="n">decoder</span> <span class="p">(</span><span class="o">-&gt;&gt;</span>
                   <span class="n">st</span>
                   <span class="n">tree</span><span class="o">-</span><span class="n">string</span>
                   <span class="n">remove</span><span class="o">-</span><span class="n">freq</span>
                   <span class="nb">hash</span><span class="o">-</span><span class="n">tree</span><span class="p">))</span>
<span class="p">(</span><span class="k">def</span> <span class="nf">hash</span><span class="o">-</span><span class="n">coder</span> <span class="p">(</span><span class="n">clojure</span><span class="o">.</span><span class="n">set</span><span class="o">/</span><span class="nb">map</span><span class="o">-</span><span class="n">invert</span> <span class="nb">hash</span><span class="o">-</span><span class="n">decoder</span><span class="p">))</span>
<span class="p">(</span><span class="n">println</span> <span class="s2">&quot;coding...&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">def</span> <span class="nf">code</span> <span class="p">(</span><span class="n">coder</span> <span class="n">st</span> <span class="nb">hash</span><span class="o">-</span><span class="n">coder</span><span class="p">))</span>
<span class="p">(</span><span class="n">clojure</span><span class="o">.</span><span class="n">pprint</span><span class="o">/</span><span class="n">pprint</span> <span class="n">code</span><span class="p">)</span>

<span class="p">(</span><span class="n">println</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">decoding...&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="n">clojure</span><span class="o">.</span><span class="n">pprint</span><span class="o">/</span><span class="n">pprint</span> <span class="p">(</span><span class="n">decoder</span> <span class="n">code</span> <span class="nb">hash</span><span class="o">-</span><span class="n">decoder</span><span class="p">))</span>
</pre></div>

</div></p>
</div><div class="py">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="c1"># Huffman Encoding</span>
<span class="c1"># Python 2.7+</span>
<span class="c1"># Submitted by Matthew Giallourakis</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="c1"># constructs the tree</span>
<span class="k">def</span> <span class="nf">build_huffman_tree</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>

    <span class="c1"># get sorted list of character and frequency pairs</span>
    <span class="n">frequencies</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="n">trees</span> <span class="o">=</span> <span class="n">frequencies</span><span class="o">.</span><span class="n">most_common</span><span class="p">()</span>

    <span class="c1"># while there is more than one tree</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

        <span class="c1"># pop off the two trees of least weight from the trees list</span>
        <span class="n">tree_left</span><span class="p">,</span><span class="n">weight_left</span> <span class="o">=</span> <span class="n">trees</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">tree_right</span><span class="p">,</span><span class="n">weight_right</span> <span class="o">=</span> <span class="n">trees</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="c1"># combine the nodes and add back to the nodes list</span>
        <span class="n">new_tree</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree_left</span><span class="p">,</span> <span class="n">tree_right</span><span class="p">]</span>
        <span class="n">new_weight</span> <span class="o">=</span> <span class="n">weight_left</span> <span class="o">+</span> <span class="n">weight_right</span>

        <span class="c1"># find the first tree that has a weight smaller than new_weight and returns its index in the list</span>
        <span class="c1"># If no such tree can be found, use len(trees) instead to append</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tree</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span> <span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">new_weight</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">trees</span><span class="p">))</span>

        <span class="c1"># insert the new tree there</span>
        <span class="n">trees</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">new_tree</span><span class="p">,</span> <span class="n">new_weight</span><span class="p">))</span>

    <span class="n">huffman_tree</span> <span class="o">=</span> <span class="n">trees</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">huffman_tree</span>

<span class="c1"># constructs the mapping with recursion</span>
<span class="k">def</span> <span class="nf">build_codebook</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>

    <span class="n">codebook</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># split the tree</span>
    <span class="n">left_tree</span><span class="p">,</span> <span class="n">right_tree</span> <span class="o">=</span> <span class="n">tree</span>

    <span class="c1"># if the left node has children, find the mapping of those children</span>
    <span class="c1"># else pair the character with the current code + 0</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">left_tree</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">codebook</span> <span class="o">+=</span> <span class="n">build_codebook</span><span class="p">(</span><span class="n">left_tree</span><span class="p">,</span> <span class="n">code</span><span class="o">+</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">codebook</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">left_tree</span><span class="p">,</span> <span class="n">code</span><span class="o">+</span><span class="s1">&#39;0&#39;</span><span class="p">))</span>

    <span class="c1"># if the right node has children, find the mapping of those children</span>
    <span class="c1"># else pair the character with the current code + 1</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">right_tree</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">codebook</span> <span class="o">+=</span> <span class="n">build_codebook</span><span class="p">(</span><span class="n">right_tree</span><span class="p">,</span> <span class="n">code</span><span class="o">+</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">codebook</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">right_tree</span><span class="p">,</span> <span class="n">code</span><span class="o">+</span><span class="s1">&#39;1&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">codebook</span>

<span class="c1"># encodes the message</span>
<span class="k">def</span> <span class="nf">huffman_encode</span><span class="p">(</span><span class="n">codebook</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>

    <span class="n">encoded_message</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="c1"># build a char -&gt; code dictionary</span>
    <span class="n">forward_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">codebook</span><span class="p">)</span>

    <span class="c1"># replace each character with its code</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">message</span><span class="p">:</span>
        <span class="n">encoded_message</span> <span class="o">+=</span> <span class="n">forward_dict</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">encoded_message</span>

<span class="c1"># decodes a message</span>
<span class="k">def</span> <span class="nf">huffman_decode</span><span class="p">(</span><span class="n">codebook</span><span class="p">,</span> <span class="n">encoded_message</span><span class="p">):</span>

    <span class="n">decoded_message</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="c1"># build a code -&gt; char dictionary</span>
    <span class="n">inverse_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">codebook</span><span class="p">])</span>

    <span class="c1"># for each bit in the encoding</span>
    <span class="c1"># if the bit is in the dictionary, replace the bit with the paired character</span>
    <span class="c1"># else look at the bit and the following bits together until a match occurs</span>
    <span class="c1"># move to the next bit not yet looked at</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">encoded_message</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">+=</span> <span class="n">bit</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">inverse_dict</span><span class="p">:</span>
            <span class="n">decoded_message</span> <span class="o">+=</span> <span class="n">inverse_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="k">return</span> <span class="n">decoded_message</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="c1"># test example</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;bibbity_bobbity&#39;</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">build_huffman_tree</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="n">codebook</span> <span class="o">=</span> <span class="n">build_codebook</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="n">encoded_message</span> <span class="o">=</span> <span class="n">huffman_encode</span><span class="p">(</span><span class="n">codebook</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
    <span class="n">decoded_message</span> <span class="o">=</span> <span class="n">huffman_decode</span><span class="p">(</span><span class="n">codebook</span><span class="p">,</span> <span class="n">encoded_message</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;message: &#39;</span> <span class="o">+</span> <span class="n">message</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;huffman tree: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;codebook: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">codebook</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;encoded message: &#39;</span> <span class="o">+</span> <span class="n">encoded_message</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;decoded message: &#39;</span> <span class="o">+</span> <span class="n">decoded_message</span><span class="p">)</span>

    <span class="c1"># prints the following:</span>
    <span class="c1">#</span>
    <span class="c1">#  message: bibbity_bobbity</span>
    <span class="c1">#  huffman_tree: [&#39;b&#39;, [[[&#39;_&#39;, &#39;o&#39;], &#39;y&#39;], [&#39;t&#39;, &#39;i&#39;]]]</span>
    <span class="c1">#  codebook: [(&#39;b&#39;, &#39;0&#39;), (&#39;_&#39;, &#39;1000&#39;), (&#39;o&#39;, &#39;1001&#39;),</span>
    <span class="c1">#             (&#39;y&#39;, &#39;101&#39;), (&#39;t&#39;, &#39;110&#39;), (&#39;i&#39;, &#39;111&#39;)]</span>
    <span class="c1">#  encoded_message: 01110011111010110000100100111110101</span>
    <span class="c1">#  decoded_message: bibbity_bobbity</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

</div></p>
</div><div class="js">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">encode</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">createTree</span><span class="p">(</span><span class="nb">str</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">codebook</span> <span class="o">=</span> <span class="n">createCodebook</span><span class="p">(</span><span class="n">tree</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="n">string</span><span class="p">:</span> <span class="p">[</span><span class="o">...</span><span class="n">str</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">c</span> <span class="o">=&gt;</span> <span class="n">codebook</span><span class="p">[</span><span class="n">c</span><span class="p">])</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">),</span>
    <span class="n">tree</span><span class="p">,</span>
    <span class="n">codebook</span>
  <span class="p">};</span>

  <span class="n">function</span> <span class="n">createTree</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">const</span> <span class="n">chars</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="n">str</span><span class="p">];</span>
    <span class="n">const</span> <span class="n">charCounts</span> <span class="o">=</span> <span class="n">chars</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="n">counts</span><span class="p">,</span> <span class="n">char</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="n">counts</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">counts</span><span class="p">;</span>
    <span class="p">},</span> <span class="p">{});</span>

    <span class="n">const</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">Object</span><span class="o">.</span><span class="n">entries</span><span class="p">(</span><span class="n">charCounts</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(([</span><span class="n">key</span><span class="p">,</span> <span class="n">weight</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="n">key</span><span class="p">,</span> <span class="n">weight</span> <span class="p">}));</span>
    <span class="n">const</span> <span class="n">priorityQueue</span> <span class="o">=</span> <span class="n">makeQueue</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">priorityQueue</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">const</span> <span class="n">left</span> <span class="o">=</span> <span class="n">priorityQueue</span><span class="o">.</span><span class="n">dequeue</span><span class="p">();</span>
      <span class="n">const</span> <span class="n">right</span> <span class="o">=</span> <span class="n">priorityQueue</span><span class="o">.</span><span class="n">dequeue</span><span class="p">();</span>
      <span class="n">priorityQueue</span><span class="o">.</span><span class="n">enqueue</span><span class="p">({</span> <span class="n">weight</span><span class="p">:</span> <span class="n">left</span><span class="o">.</span><span class="n">weight</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="p">});</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">priorityQueue</span><span class="o">.</span><span class="n">dequeue</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">function</span> <span class="n">createCodebook</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">recurse</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="p">{});</span>

    <span class="n">function</span> <span class="n">recurse</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">bitstring</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="err">!</span><span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="err">!</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">dict</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">bitstring</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">recurse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">bitstring</span> <span class="o">+</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">recurse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">bitstring</span> <span class="o">+</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nb">dict</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">function</span> <span class="n">decode</span><span class="p">(</span><span class="n">bitstring</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">result</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="n">let</span> <span class="n">node</span> <span class="o">=</span> <span class="n">tree</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">const</span> <span class="n">bit</span> <span class="n">of</span> <span class="p">[</span><span class="o">...</span><span class="n">bitstring</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">bit</span> <span class="o">===</span> <span class="s2">&quot;0&quot;</span> <span class="err">?</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="err">!</span><span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="err">!</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">result</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">key</span><span class="p">);</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">tree</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">This</span> <span class="n">queue</span> <span class="n">implementation</span> <span class="ow">is</span> <span class="n">horribly</span> <span class="n">inefficient</span><span class="p">,</span> <span class="n">but</span> <span class="n">a</span> <span class="n">proper</span><span class="p">,</span> <span class="n">heap</span><span class="o">-</span><span class="n">based</span> <span class="n">implementation</span> <span class="n">would</span>
<span class="o">//</span> <span class="n">be</span> <span class="n">longer</span> <span class="n">that</span> <span class="n">the</span> <span class="n">algorithm</span> <span class="n">itself</span>
<span class="n">function</span> <span class="n">makeQueue</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="p">[</span><span class="o">...</span><span class="n">iterable</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">weight</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">weight</span><span class="p">),</span>
    <span class="n">enqueue</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">const</span> <span class="n">target</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">findIndex</span><span class="p">(</span><span class="n">x</span> <span class="o">=&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">weight</span> <span class="o">&gt;</span> <span class="n">value</span><span class="o">.</span><span class="n">weight</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="n">this</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">target</span><span class="p">),</span> <span class="n">value</span><span class="p">,</span> <span class="o">...</span><span class="n">this</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">target</span><span class="p">)];</span>
      <span class="p">}</span>
    <span class="p">},</span>
    <span class="n">dequeue</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shift</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="n">const</span> <span class="n">encoded</span> <span class="o">=</span> <span class="n">encode</span><span class="p">(</span><span class="s2">&quot;bibbity bobbity&quot;</span><span class="p">);</span>
<span class="n">const</span> <span class="n">decoded</span> <span class="o">=</span> <span class="n">decode</span><span class="p">(</span><span class="n">encoded</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">encoded</span><span class="o">.</span><span class="n">tree</span><span class="p">);</span>
<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">encoded</span><span class="o">.</span><span class="n">string</span><span class="p">);</span>
<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">decoded</span><span class="p">);</span>
</pre></div>

</div></p>
</div><div class="java">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">java.util.</span><span class="o">*</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">TreeNode</span> <span class="p">{</span>
    <span class="n">String</span> <span class="n">letter</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">frequency</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="n">left</span> <span class="o">=</span> <span class="n">null</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>

    <span class="n">public</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">String</span> <span class="n">letter</span><span class="p">,</span> <span class="nb">int</span> <span class="n">frequency</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">letter</span> <span class="o">=</span> <span class="n">letter</span><span class="p">;</span>
        <span class="n">this</span><span class="o">.</span><span class="n">frequency</span> <span class="o">=</span> <span class="n">frequency</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">int</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="n">left</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">frequency</span> <span class="o">=</span> <span class="n">frequency</span><span class="p">;</span>
        <span class="n">this</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
        <span class="n">this</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">HuffmanTree</span> <span class="p">{</span>
    <span class="n">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">frequencyMap</span> <span class="o">=</span> <span class="n">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span>
    <span class="n">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">codeBook</span> <span class="o">=</span> <span class="n">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">(),</span> <span class="n">reverseCodeBook</span> <span class="o">=</span> <span class="n">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span>
    <span class="n">private</span> <span class="n">TreeNode</span> <span class="n">root</span><span class="p">;</span>
    <span class="n">private</span> <span class="n">String</span> <span class="n">stringToEncode</span><span class="p">;</span>

    <span class="n">public</span> <span class="n">HuffmanTree</span><span class="p">(</span><span class="n">String</span> <span class="n">stringToEncode</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">stringToEncode</span> <span class="o">=</span> <span class="n">stringToEncode</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">void</span> <span class="n">createTree</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stringToEncode</span><span class="o">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">Character</span><span class="o">.</span><span class="n">toString</span><span class="p">(</span><span class="n">stringToEncode</span><span class="o">.</span><span class="n">charAt</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
            <span class="k">if</span> <span class="p">(</span><span class="err">!</span><span class="n">frequencyMap</span><span class="o">.</span><span class="n">containsKey</span><span class="p">(</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">frequencyMap</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nb">int</span> <span class="n">frequency</span> <span class="o">=</span> <span class="n">frequencyMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">frequencyMap</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">frequency</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">priorityQueue</span> <span class="o">=</span> <span class="n">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">Comparator</span><span class="o">.</span><span class="n">comparingInt</span><span class="p">(</span><span class="n">o</span> <span class="o">-&gt;</span> <span class="n">o</span><span class="o">.</span><span class="n">frequency</span><span class="p">));</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">Map</span><span class="o">.</span><span class="n">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">m</span> <span class="p">:</span> <span class="n">frequencyMap</span><span class="o">.</span><span class="n">entrySet</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">priorityQueue</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">getKey</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">getValue</span><span class="p">()));</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">priorityQueue</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="n">left</span> <span class="o">=</span> <span class="n">priorityQueue</span><span class="o">.</span><span class="n">remove</span><span class="p">();</span>
            <span class="n">TreeNode</span> <span class="n">right</span> <span class="o">=</span> <span class="n">priorityQueue</span><span class="o">.</span><span class="n">remove</span><span class="p">();</span>
            <span class="n">priorityQueue</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">frequency</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">frequency</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">priorityQueue</span><span class="o">.</span><span class="n">remove</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">private</span> <span class="n">void</span> <span class="n">traverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="n">node</span><span class="p">,</span> <span class="n">StringBuilder</span> <span class="n">code</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">null</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">codeBook</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">letter</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">toString</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
            <span class="n">code</span><span class="o">.</span><span class="n">deleteCharAt</span><span class="p">(</span><span class="n">code</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
            <span class="n">code</span><span class="o">.</span><span class="n">deleteCharAt</span><span class="p">(</span><span class="n">code</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">void</span> <span class="n">printCodeBook</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;Code Book&quot;</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">Map</span><span class="o">.</span><span class="n">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">m</span> <span class="p">:</span> <span class="n">codeBook</span><span class="o">.</span><span class="n">entrySet</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">getKey</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">getValue</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">private</span> <span class="n">void</span> <span class="n">CodeBookReverse</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">Map</span><span class="o">.</span><span class="n">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">m</span> <span class="p">:</span> <span class="n">codeBook</span><span class="o">.</span><span class="n">entrySet</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">reverseCodeBook</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">getValue</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">getKey</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">String</span> <span class="n">encode</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">new</span> <span class="n">StringBuilder</span><span class="p">());</span>
        <span class="n">StringBuilder</span> <span class="n">encode</span> <span class="o">=</span> <span class="n">new</span> <span class="n">StringBuilder</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stringToEncode</span><span class="o">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">String</span> <span class="n">k</span> <span class="o">=</span> <span class="n">Character</span><span class="o">.</span><span class="n">toString</span><span class="p">(</span><span class="n">stringToEncode</span><span class="o">.</span><span class="n">charAt</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
            <span class="n">encode</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">codeBook</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">printCodeBook</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">encode</span><span class="o">.</span><span class="n">toString</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">String</span> <span class="n">decode</span><span class="p">(</span><span class="n">String</span> <span class="n">encoded</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">StringBuilder</span> <span class="n">decoded</span> <span class="o">=</span> <span class="n">new</span> <span class="n">StringBuilder</span><span class="p">(),</span> <span class="n">key</span> <span class="o">=</span> <span class="n">new</span> <span class="n">StringBuilder</span><span class="p">();</span>
        <span class="n">CodeBookReverse</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">encoded</span><span class="o">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">encoded</span><span class="o">.</span><span class="n">charAt</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">reverseCodeBook</span><span class="o">.</span><span class="n">containsKey</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">toString</span><span class="p">()))</span> <span class="p">{</span>
                <span class="n">decoded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reverseCodeBook</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">toString</span><span class="p">()));</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">new</span> <span class="n">StringBuilder</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">decoded</span><span class="o">.</span><span class="n">toString</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Huffman</span> <span class="p">{</span>
    <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">HuffmanTree</span> <span class="n">huffmanTree</span> <span class="o">=</span> <span class="n">new</span> <span class="n">HuffmanTree</span><span class="p">(</span><span class="s2">&quot;bibbity_bobbity&quot;</span><span class="p">);</span>
        <span class="n">huffmanTree</span><span class="o">.</span><span class="n">createTree</span><span class="p">();</span>
        <span class="n">String</span> <span class="n">encoded</span> <span class="o">=</span> <span class="n">huffmanTree</span><span class="o">.</span><span class="n">encode</span><span class="p">();</span>
        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;Encoded String: &quot;</span> <span class="o">+</span> <span class="n">encoded</span><span class="p">);</span>
        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;Decoded String: &quot;</span> <span class="o">+</span> <span class="n">huffmanTree</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoded</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="go">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s2">&quot;container/heap&quot;</span>
	<span class="s2">&quot;fmt&quot;</span>
<span class="p">)</span>

<span class="nb">type</span> <span class="n">node</span> <span class="n">struct</span> <span class="p">{</span>
	<span class="n">freq</span>  <span class="nb">int</span>
	<span class="n">char</span>  <span class="n">rune</span>
	<span class="n">left</span>  <span class="o">*</span><span class="n">node</span>
	<span class="n">right</span> <span class="o">*</span><span class="n">node</span>
<span class="p">}</span>

<span class="nb">type</span> <span class="n">codebook</span> <span class="nb">map</span><span class="p">[</span><span class="n">rune</span><span class="p">]</span><span class="n">string</span>
<span class="nb">type</span> <span class="n">nodeHeap</span> <span class="p">[]</span><span class="o">*</span><span class="n">node</span>

<span class="n">func</span> <span class="p">(</span><span class="n">n</span> <span class="n">nodeHeap</span><span class="p">)</span> <span class="n">Len</span><span class="p">()</span> <span class="nb">int</span>           <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">}</span>
<span class="n">func</span> <span class="p">(</span><span class="n">n</span> <span class="n">nodeHeap</span><span class="p">)</span> <span class="n">Less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="nb">int</span><span class="p">)</span> <span class="nb">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">freq</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">freq</span> <span class="p">}</span>
<span class="n">func</span> <span class="p">(</span><span class="n">n</span> <span class="n">nodeHeap</span><span class="p">)</span> <span class="n">Swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="nb">int</span><span class="p">)</span>      <span class="p">{</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">nodeHeap</span><span class="p">)</span> <span class="n">Push</span><span class="p">(</span><span class="n">x</span> <span class="n">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">node</span><span class="p">,</span> <span class="n">ok</span> <span class="p">:</span><span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;I got a node of Type %T</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">nodeHeap</span><span class="p">)</span> <span class="n">Pop</span><span class="p">()</span> <span class="n">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="n">old</span> <span class="p">:</span><span class="o">=</span> <span class="o">*</span><span class="n">n</span>
	<span class="n">l</span> <span class="p">:</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
	<span class="n">x</span> <span class="p">:</span><span class="o">=</span> <span class="n">old</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">old</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">x</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">message</span> <span class="n">string</span><span class="p">)</span> <span class="o">*</span><span class="n">node</span> <span class="p">{</span>
	<span class="n">freqMap</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">(</span><span class="nb">map</span><span class="p">[</span><span class="n">rune</span><span class="p">]</span><span class="o">*</span><span class="n">node</span><span class="p">)</span>
	<span class="n">h</span> <span class="p">:</span><span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">nodeHeap</span><span class="p">)</span>
	<span class="n">heap</span><span class="o">.</span><span class="n">Init</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">//</span> <span class="n">really</span> <span class="n">needed</span><span class="err">?</span>

	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">char</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">message</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="p">:</span><span class="o">=</span> <span class="n">freqMap</span><span class="p">[</span><span class="n">char</span><span class="p">];</span> <span class="n">ok</span> <span class="p">{</span>
			<span class="n">freqMap</span><span class="p">[</span><span class="n">char</span><span class="p">]</span><span class="o">.</span><span class="n">freq</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">newNode</span> <span class="p">:</span><span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
			<span class="n">newNode</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="n">newNode</span><span class="o">.</span><span class="n">char</span> <span class="o">=</span> <span class="n">char</span>
			<span class="n">freqMap</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">newNode</span>
			<span class="n">heap</span><span class="o">.</span><span class="n">Push</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">newNode</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="n">h</span><span class="o">.</span><span class="n">Len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="p">:</span><span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">Pop</span><span class="p">()</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">),</span> <span class="n">h</span><span class="o">.</span><span class="n">Pop</span><span class="p">()</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)</span>
		<span class="n">branch</span> <span class="p">:</span><span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
		<span class="n">branch</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">freq</span> <span class="o">+</span> <span class="n">left</span><span class="o">.</span><span class="n">freq</span>
		<span class="n">branch</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
		<span class="n">branch</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
		<span class="n">heap</span><span class="o">.</span><span class="n">Push</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">branch</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="n">root</span> <span class="p">:</span><span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="n">Pop</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">root</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">codebookRecurse</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">cb</span> <span class="o">*</span><span class="n">codebook</span><span class="p">,</span> <span class="n">code</span> <span class="p">[]</span><span class="n">rune</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">nil</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">nil</span> <span class="p">{</span>
		<span class="p">(</span><span class="o">*</span><span class="n">cb</span><span class="p">)[</span><span class="n">node</span><span class="o">.</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">string</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="n">code</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
	<span class="n">codebookRecurse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span>
	<span class="n">code</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">code</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">code</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
	<span class="n">codebookRecurse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">encode</span><span class="p">(</span><span class="n">message</span> <span class="n">string</span><span class="p">)</span> <span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">codebook</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">ret</span> <span class="p">:</span><span class="o">=</span> <span class="s2">&quot;&quot;</span>
	<span class="n">root</span> <span class="p">:</span><span class="o">=</span> <span class="n">buildTree</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
	<span class="n">cb</span> <span class="p">:</span><span class="o">=</span> <span class="n">generateCodebook</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">char</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">message</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">cb</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">cb</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">decode</span><span class="p">(</span><span class="n">message</span> <span class="n">string</span><span class="p">,</span> <span class="n">root</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="n">string</span> <span class="p">{</span>
	<span class="n">cur</span> <span class="p">:</span><span class="o">=</span> <span class="n">root</span>
	<span class="n">ret</span> <span class="p">:</span><span class="o">=</span> <span class="s2">&quot;&quot;</span>

	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">char</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">message</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">cur</span> <span class="o">==</span> <span class="n">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">message</span>
		<span class="p">}</span>

		<span class="n">switch</span> <span class="n">string</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">case</span> <span class="s2">&quot;0&quot;</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">cur</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">nil</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">+=</span> <span class="n">string</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">char</span><span class="p">)</span>
				<span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">left</span>
			<span class="p">}</span>
		<span class="n">case</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">cur</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">nil</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">+=</span> <span class="n">string</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">char</span><span class="p">)</span>
				<span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">right</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="n">cur</span><span class="o">.</span><span class="n">char</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">string</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">char</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">generateCodebook</span><span class="p">(</span><span class="n">root</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="n">codebook</span> <span class="p">{</span>
	<span class="n">cb</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">(</span><span class="n">codebook</span><span class="p">)</span>
	<span class="n">codeArr</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="n">rune</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="n">codebookRecurse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cb</span><span class="p">,</span> <span class="n">codeArr</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">cb</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">enc</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">cb</span> <span class="p">:</span><span class="o">=</span> <span class="n">encode</span><span class="p">(</span><span class="s2">&quot;bibbity_bobbity&quot;</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;Codebook:&quot;</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">cb</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Encoded:&quot;</span><span class="p">,</span> <span class="n">enc</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;Decoded:&quot;</span><span class="p">,</span> <span class="n">decode</span><span class="p">(</span><span class="n">enc</span><span class="p">,</span> <span class="n">root</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="asm-x64">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="o">.</span><span class="n">intel_syntax</span> <span class="n">noprefix</span>

<span class="c1"># System V calling convention cheatsheet</span>
<span class="c1"># Params: rdi, rsi, rdx, rcx, r8, r9, xmm0-7</span>
<span class="c1"># Return: rax (int 64 bits), rax:rdx (int 128 bits), xmm0 (float)</span>
<span class="c1"># Callee cleanup: rbx, rbp, r12-15</span>
<span class="c1"># Scratch: rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11</span>

<span class="o">.</span><span class="n">section</span> <span class="o">.</span><span class="n">rodata</span>
  <span class="n">text</span><span class="p">:</span>       <span class="o">.</span><span class="n">string</span> <span class="s2">&quot;bibbity bobbity&quot;</span>
  <span class="n">original</span><span class="p">:</span>   <span class="o">.</span><span class="n">string</span> <span class="s2">&quot;Original message: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span>
  <span class="n">encoded</span><span class="p">:</span>    <span class="o">.</span><span class="n">string</span> <span class="s2">&quot;Encoded message: &quot;</span>
  <span class="n">decoded</span><span class="p">:</span>    <span class="o">.</span><span class="n">string</span> <span class="s2">&quot;Decoded message: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span>

  <span class="o">.</span><span class="n">equ</span> <span class="n">bitstr_len</span><span class="p">,</span>       <span class="mi">32</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">bitstr_size</span><span class="p">,</span>      <span class="mi">40</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">codebook_size</span><span class="p">,</span>    <span class="mi">256</span> <span class="o">*</span> <span class="n">bitstr_size</span>

  <span class="o">.</span><span class="n">equ</span> <span class="n">tree_left</span><span class="p">,</span>        <span class="mi">0</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">tree_right</span><span class="p">,</span>       <span class="mi">8</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">tree_count</span><span class="p">,</span>       <span class="mi">16</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">tree_value</span><span class="p">,</span>       <span class="mi">20</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">tree_size</span><span class="p">,</span>        <span class="mi">24</span>

  <span class="o">.</span><span class="n">equ</span> <span class="n">heap_len</span><span class="p">,</span>         <span class="mi">0</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">heap_data</span><span class="p">,</span>        <span class="mi">4</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">heap_size</span><span class="p">,</span>        <span class="mi">512</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">16</span>         <span class="c1"># 512 ptrs + 4 byte length + 12 byte padding</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">counts_size</span><span class="p">,</span>      <span class="mi">256</span> <span class="o">*</span> <span class="mi">4</span>

  <span class="o">.</span><span class="n">equ</span> <span class="n">msg_len</span><span class="p">,</span>          <span class="mi">0</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">msg_data</span><span class="p">,</span>         <span class="mi">8</span>
<span class="o">.</span><span class="n">section</span> <span class="o">.</span><span class="n">text</span>
  <span class="o">.</span><span class="k">global</span> <span class="n">main</span>
  <span class="o">.</span><span class="n">extern</span> <span class="n">printf</span><span class="p">,</span> <span class="n">calloc</span><span class="p">,</span> <span class="n">malloc</span><span class="p">,</span> <span class="n">memset</span><span class="p">,</span> <span class="n">puts</span>

<span class="n">main</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">sub</span>    <span class="n">rsp</span><span class="p">,</span> <span class="n">codebook_size</span> <span class="o">+</span> <span class="mi">16</span>              <span class="c1"># 8 extra bytes for the Huffman-tree ptr, 8 bytes for padding</span>

  <span class="c1"># Print the original text</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">original</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">text</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>

  <span class="c1"># First encode the text. This will also initialize the Huffman-tree and the codebook</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">text</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">rsp</span>
  <span class="n">lea</span>    <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="n">codebook_size</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">encode</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rax</span>                             <span class="c1"># Save the returned message ptr</span>

  <span class="c1"># Print the codebook and the encoded message</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">rsp</span>
  <span class="n">call</span>   <span class="n">print_codebook</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">encoded</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>
  <span class="n">call</span>   <span class="n">print_message</span>

  <span class="c1"># Decode and print the message</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="n">codebook_size</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">decode</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">decoded</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">r13</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>

  <span class="c1"># Free allocated resources</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>
  <span class="n">call</span>   <span class="n">free</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r13</span>
  <span class="n">call</span>   <span class="n">free</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="n">codebook_size</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">free_tree</span>

  <span class="n">add</span>    <span class="n">rsp</span><span class="p">,</span> <span class="n">codebook_size</span> <span class="o">+</span> <span class="mi">16</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>

  <span class="c1"># Indiciate success with a 0 exit code</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">ret</span>

<span class="c1"># rdi - text</span>
<span class="c1"># rsi - codebook ptr</span>
<span class="c1"># rdx - Huffman-tree ptr</span>
<span class="c1"># RET rax - encoded message ptr</span>
<span class="n">encode</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">push</span>   <span class="n">r14</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rdi</span>                             <span class="c1"># Save the original arguments</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">mov</span>    <span class="n">r14</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">call</span>   <span class="n">generate_tree</span>                        <span class="c1"># The text is already in rdi</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r14</span><span class="p">],</span> <span class="n">rax</span>                 <span class="c1"># Save the Huffman-tree&#39;s root</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r13</span>                             <span class="c1"># Set up the parameters for codebook generation: codebook ptr, Huffman-tree root</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">generate_codebook</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">xor</span>    <span class="n">r14</span><span class="p">,</span> <span class="n">r14</span>                             <span class="c1"># We&#39;ll use r14 to keep track of the length of the message</span>
  <span class="n">mov</span>    <span class="n">rcx</span><span class="p">,</span> <span class="n">r12</span>                             <span class="c1"># Make a copy of the pointer to the message to be encoded</span>
<span class="n">encode_calculate_length</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">al</span><span class="p">,</span> <span class="n">BYTE</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
  <span class="n">test</span>   <span class="n">al</span><span class="p">,</span> <span class="n">al</span>                               <span class="c1"># If we&#39;re at the terminating null character then we&#39;re ready to encode</span>
  <span class="n">jz</span>     <span class="n">encode_message</span>
  <span class="n">lea</span>    <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">rax</span><span class="p">]</span>                   <span class="c1"># We get the codebook entry at the specific index</span>
  <span class="n">lea</span>    <span class="n">r8</span><span class="p">,</span> <span class="p">[</span><span class="n">r13</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">rdx</span><span class="p">]</span>
  <span class="n">add</span>    <span class="n">r14</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r8</span> <span class="o">+</span> <span class="n">bitstr_len</span><span class="p">]</span>     <span class="c1"># And add the encoded word length to the total</span>
  <span class="n">inc</span>    <span class="n">rcx</span>
  <span class="n">jmp</span>    <span class="n">encode_calculate_length</span>
<span class="n">encode_message</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="mi">1</span>
  <span class="n">lea</span>    <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]</span>                       <span class="c1"># Calculate the number of bytes we need to allocate to fit all the bits</span>
  <span class="n">shr</span>    <span class="n">rsi</span><span class="p">,</span> <span class="mi">3</span>                               <span class="c1"># length % 8 rounded up = (length + 8 - 1) / 8</span>
  <span class="n">lea</span>    <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rsi</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>                       <span class="c1"># Make space for an 8-byte length field</span>
  <span class="n">call</span>   <span class="n">calloc</span>                               <span class="c1"># Allocate the necessary memory, the message will be in rax</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">r14</span>                 <span class="c1"># Save the length of the message</span>
  <span class="c1"># Registers:</span>
  <span class="c1">#   - r12: text</span>
  <span class="c1">#   - r13: codebook_ptr</span>
  <span class="c1">#   - rax: message ptr</span>
  <span class="c1">#   - free to use: rdi, rsi, rcx, rdx, r8, r9, r10, r11, r14</span>
  <span class="n">xor</span>    <span class="n">r8</span><span class="p">,</span> <span class="n">r8</span>                               <span class="c1"># Bit offset</span>
  <span class="n">lea</span>    <span class="n">r9</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>                        <span class="c1"># 8-byte message block</span>
<span class="n">encode_message_bits</span><span class="p">:</span>
  <span class="n">xor</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">rdi</span>                             <span class="c1"># We need to clear rdi because moving a single byte to dil doesn&#39;t do so</span>
  <span class="n">mov</span>    <span class="n">dil</span><span class="p">,</span> <span class="n">BYTE</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span><span class="p">]</span>                  <span class="c1"># Iterate the message again</span>
  <span class="n">test</span>   <span class="n">dil</span><span class="p">,</span> <span class="n">dil</span>                             <span class="c1"># If we&#39;re at the the null terminator we&#39;re done</span>
  <span class="n">jz</span>     <span class="n">encode_done</span>
  <span class="n">lea</span>    <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">rdi</span><span class="p">]</span>                   <span class="c1"># Get the codebook entry</span>
  <span class="n">lea</span>    <span class="n">r10</span><span class="p">,</span> <span class="p">[</span><span class="n">r13</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">rdx</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">r11</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r10</span> <span class="o">+</span> <span class="n">bitstr_len</span><span class="p">]</span>    <span class="c1"># Load the bitstring length</span>
  <span class="n">lea</span>    <span class="n">r14</span><span class="p">,</span> <span class="p">[</span><span class="n">r10</span><span class="p">]</span>                           <span class="c1"># The bitstring qword we&#39;re currently processing</span>
<span class="n">encode_message_bits_qword</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r14</span><span class="p">]</span>                 <span class="c1"># Calculate the first mask: [code qword] &lt;&lt; [bit offset]</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">rdi</span>                             <span class="c1"># Get a second copy of the code&#39;s current qword</span>
  <span class="n">mov</span>    <span class="n">rcx</span><span class="p">,</span> <span class="n">r8</span>
  <span class="n">shl</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">cl</span>
  <span class="ow">or</span>     <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r9</span><span class="p">],</span> <span class="n">rdi</span>                  <span class="c1"># Apply the mask to the current block</span>
  <span class="n">mov</span>    <span class="n">rcx</span><span class="p">,</span> <span class="mi">64</span>                              <span class="c1"># Calculate the second mask: [code qword] &gt;&gt; [64 - bit offset]</span>
  <span class="n">sub</span>    <span class="n">rcx</span><span class="p">,</span> <span class="n">r8</span>
  <span class="n">shr</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">cl</span>
  <span class="n">mov</span>    <span class="n">rcx</span><span class="p">,</span> <span class="n">r11</span>                             <span class="c1"># Copy the code length so we can manipulate it without destroying the original value</span>
  <span class="n">sub</span>    <span class="n">rcx</span><span class="p">,</span> <span class="mi">64</span>
  <span class="n">jle</span>    <span class="n">encode_message_bits_try_overflow</span>     <span class="c1"># If the length was less than or equal to 64, check if the code qword would overflow the current message block</span>
  <span class="n">mov</span>    <span class="n">r11</span><span class="p">,</span> <span class="n">rcx</span>                             <span class="c1"># We wanted to subtract 64 from the code length anyway</span>
  <span class="n">lea</span>    <span class="n">r9</span><span class="p">,</span> <span class="p">[</span><span class="n">r9</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>                         <span class="c1"># Load the next message block</span>
  <span class="ow">or</span>     <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r9</span><span class="p">],</span> <span class="n">rsi</span>                  <span class="c1"># Save the second mask to the new message block</span>
  <span class="n">jmp</span>    <span class="n">encode_message_bits_qword</span>
<span class="n">encode_message_bits_try_overflow</span><span class="p">:</span>
  <span class="n">add</span>    <span class="n">rcx</span><span class="p">,</span> <span class="n">r8</span>                              <span class="c1"># Calculate [code length] + [bit offset] - 64</span>
  <span class="n">jl</span>     <span class="n">encode_calculate_new_bit_offset</span>      <span class="c1"># If the result is less than 0 then we have no remaining bits -&gt; calculate the new bit offset</span>
  <span class="n">mov</span>    <span class="n">r8</span><span class="p">,</span> <span class="n">rcx</span>                              <span class="c1"># Otherwise this also happens to be our new bit offset</span>
  <span class="n">lea</span>    <span class="n">r9</span><span class="p">,</span> <span class="p">[</span><span class="n">r9</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>                         <span class="c1"># Load the next message block</span>
  <span class="ow">or</span>     <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r9</span><span class="p">],</span> <span class="n">rsi</span>                  <span class="c1"># Save the second mask to the new message block</span>
  <span class="n">inc</span>    <span class="n">r12</span>                                  <span class="c1"># Go to the next character in the input</span>
  <span class="n">jmp</span>    <span class="n">encode_message_bits</span>
<span class="n">encode_calculate_new_bit_offset</span><span class="p">:</span>
  <span class="n">lea</span>    <span class="n">r8</span><span class="p">,</span> <span class="p">[</span><span class="n">r8</span> <span class="o">+</span> <span class="n">r11</span><span class="p">]</span>                       <span class="c1"># Calculate the bit offset for the next code qword</span>
  <span class="n">inc</span>    <span class="n">r12</span>
  <span class="n">jmp</span>    <span class="n">encode_message_bits</span>
<span class="n">encode_done</span><span class="p">:</span>
  <span class="n">pop</span>    <span class="n">r14</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>

<span class="c1"># rdi - encoded message</span>
<span class="c1"># rsi - Huffman-tree root (ptr)</span>
<span class="c1"># RET rax - the decoded message</span>
<span class="n">decode</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">push</span>   <span class="n">r14</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span><span class="p">]</span>                 <span class="c1"># Load the length of the message</span>
  <span class="n">mov</span>    <span class="n">r14</span><span class="p">,</span> <span class="n">rdi</span>                             <span class="c1"># We&#39;ll use the length of the message as a loop counter later</span>
  <span class="n">lea</span>    <span class="n">rdi</span><span class="p">,</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>                       <span class="c1"># The null terminator</span>
  <span class="n">call</span>   <span class="n">malloc</span>                               <span class="c1"># This will usually be more than enough memory to contain the whole decoded message (we don&#39;t handle pathological cases right now)</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>                             <span class="c1"># The single-character decoder doesn&#39;t touch rdi so we can hoist it before the loop</span>
  <span class="n">xor</span>    <span class="n">rcx</span><span class="p">,</span> <span class="n">rcx</span>
  <span class="n">mov</span>    <span class="n">rdx</span><span class="p">,</span> <span class="n">rax</span>                             <span class="c1"># The current byte in the output string</span>
<span class="n">decode_loop</span><span class="p">:</span>
  <span class="nb">cmp</span>    <span class="n">rcx</span><span class="p">,</span> <span class="n">r14</span>                             <span class="c1"># The encoded message bit counter</span>
  <span class="n">jge</span>    <span class="n">decode_done</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">r13</span>                             <span class="c1"># The current node in the Huffman-tree</span>
<span class="n">decode_loop_char</span><span class="p">:</span>
  <span class="n">test</span>   <span class="n">rsi</span><span class="p">,</span> <span class="n">rsi</span>                             <span class="c1"># If the Huffman-tree node is null then we reached a dead-end -&gt; start over</span>
  <span class="n">jz</span>     <span class="n">decode_loop</span>
  <span class="nb">cmp</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rsi</span> <span class="o">+</span> <span class="n">tree_left</span><span class="p">],</span> <span class="mi">0</span>       <span class="c1"># If the node has either a left or a right child, treat it as a branch</span>
  <span class="n">jnz</span>    <span class="n">decode_loop_char_branch</span>
  <span class="nb">cmp</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rsi</span> <span class="o">+</span> <span class="n">tree_right</span><span class="p">],</span> <span class="mi">0</span>
  <span class="n">jnz</span>    <span class="n">decode_loop_char_branch</span>
  <span class="n">mov</span>    <span class="n">r9d</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rsi</span> <span class="o">+</span> <span class="n">tree_value</span><span class="p">]</span>    <span class="c1"># Load the value in this node in case the next iteration needs it</span>
  <span class="n">mov</span>    <span class="n">BYTE</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span><span class="p">],</span> <span class="n">r9b</span>                  <span class="c1"># And save it to the output</span>
  <span class="n">lea</span>    <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>                       <span class="c1"># Advance the output string</span>
  <span class="n">jmp</span>    <span class="n">decode_loop</span>
<span class="n">decode_loop_char_branch</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">r9</span><span class="p">,</span> <span class="n">rcx</span>                              <span class="c1"># First, load the byte of the message the current bit is in</span>
  <span class="n">shr</span>    <span class="n">r9</span><span class="p">,</span> <span class="mi">3</span>
  <span class="n">mov</span>    <span class="n">r10b</span><span class="p">,</span> <span class="n">BYTE</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="n">r9</span> <span class="o">+</span> <span class="n">msg_data</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">r11</span><span class="p">,</span> <span class="n">rcx</span>                             <span class="c1"># Save rcx in another register temporarily so we can restore it without push/pop</span>
  <span class="ow">and</span>    <span class="n">rcx</span><span class="p">,</span> <span class="mi">7</span>
  <span class="n">shr</span>    <span class="n">r10</span><span class="p">,</span> <span class="n">cl</span>                              <span class="c1"># Get the bit we&#39;re interested in to position 0</span>
  <span class="n">lea</span>    <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">r11</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>                       <span class="c1"># Restore rcx and immediately add 1 to get the next bit to decode</span>
  <span class="ow">and</span>    <span class="n">r10</span><span class="p">,</span> <span class="mh">0x1</span>                             <span class="c1"># Zero out all other bits</span>
  <span class="n">mov</span>    <span class="n">r8</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r8</span> <span class="o">+</span> <span class="n">tree_left</span><span class="p">]</span>      <span class="c1"># Take the left branch for 0, the right branch for a non-zero bit</span>
  <span class="n">cmovnz</span> <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r8</span> <span class="o">+</span> <span class="n">tree_right</span><span class="p">]</span>
  <span class="n">jmp</span>    <span class="n">decode_loop_char</span>
<span class="n">decode_done</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">BYTE</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span><span class="p">],</span> <span class="mi">0</span>                    <span class="c1"># Write the null terminator at the end of the string</span>
  <span class="n">pop</span>    <span class="n">r14</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>

<span class="c1"># rdi - The starting address of the codebook we want to generate</span>
<span class="c1"># rsi - Huffman-tree root (ptr)</span>
<span class="n">generate_codebook</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">sub</span>    <span class="n">rsp</span><span class="p">,</span> <span class="n">bitstr_size</span> <span class="o">+</span> <span class="mi">16</span>                <span class="c1"># 16 extra bytes for alignment</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">xorps</span>  <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmm0</span>                           <span class="c1"># Create a 0-initialized bitstring. This will be</span>
  <span class="n">movaps</span> <span class="n">XMMWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rsp</span><span class="p">],</span> <span class="n">xmm0</span>              <span class="c1"># used in the recursive function calls</span>
  <span class="n">movaps</span> <span class="n">XMMWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">xmm0</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">32</span><span class="p">],</span> <span class="mi">0</span>
  <span class="n">xor</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">mov</span>    <span class="n">rdx</span><span class="p">,</span> <span class="n">codebook_size</span>
  <span class="n">call</span>   <span class="n">memset</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">r12</span>
  <span class="n">mov</span>    <span class="n">rdx</span><span class="p">,</span> <span class="n">rsp</span>
  <span class="n">call</span>   <span class="n">generate_codebook_recurse</span>
  <span class="n">add</span>    <span class="n">rsp</span><span class="p">,</span> <span class="n">bitstr_size</span> <span class="o">+</span> <span class="mi">16</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>

<span class="c1"># rdi - The codebook&#39;s starting address</span>
<span class="c1"># rsi - The current Huffman-tree node</span>
<span class="c1"># rdx - The bitstring used for code generation</span>
<span class="n">generate_codebook_recurse</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">rbp</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">test</span>   <span class="n">rdi</span><span class="p">,</span> <span class="n">rdi</span>                             <span class="c1"># If we reached a null pointer we&#39;re done</span>
  <span class="n">jz</span>     <span class="n">generate_codebook_recurse_done</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="nb">cmp</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="n">tree_left</span><span class="p">],</span> <span class="mi">0</span>       <span class="c1"># If at least one of the children is not null</span>
  <span class="n">jnz</span>    <span class="n">generate_codebook_branch</span>             <span class="c1"># then we need to treat the current node as a branch</span>
  <span class="nb">cmp</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="n">tree_right</span><span class="p">],</span> <span class="mi">0</span>
  <span class="n">jnz</span>    <span class="n">generate_codebook_branch</span>
  <span class="n">mov</span>    <span class="n">r8d</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="n">tree_value</span><span class="p">]</span>    <span class="c1"># Get the value of the current node</span>
  <span class="n">movaps</span> <span class="n">xmm0</span><span class="p">,</span> <span class="n">XMMWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span><span class="p">]</span>              <span class="c1"># Get the values of the current bitstring into some registers</span>
  <span class="n">movaps</span> <span class="n">xmm1</span><span class="p">,</span> <span class="n">XMMWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">r9</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">32</span><span class="p">]</span>
  <span class="n">lea</span>    <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">r8</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">r8</span><span class="p">]</span>                     <span class="c1"># The index calculation needs to add 40 * index. With lea arithmetic this can be represented as</span>
  <span class="n">lea</span>    <span class="n">r10</span><span class="p">,</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">rax</span><span class="p">]</span>                   <span class="c1"># base address + 8 * (5 * index). This is done in two lea instructions</span>
  <span class="n">movups</span> <span class="n">XMMWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r10</span><span class="p">],</span> <span class="n">xmm0</span>              <span class="c1"># And copy the data over to it</span>
  <span class="n">movups</span> <span class="n">XMMWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r10</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">xmm1</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r10</span> <span class="o">+</span> <span class="mi">32</span><span class="p">],</span> <span class="n">r9</span>
  <span class="n">jmp</span>    <span class="n">generate_codebook_recurse_done</span>
<span class="n">generate_codebook_branch</span><span class="p">:</span>
  <span class="c1"># First, calculate the necessary indices and bitmask to use for the bitstring</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="n">bitstr_len</span><span class="p">]</span>    <span class="c1"># Load the current length of the bitstring</span>
  <span class="n">mov</span>    <span class="n">rcx</span><span class="p">,</span> <span class="n">r13</span>                             <span class="c1"># This will be used to index into the bitstring data. We&#39;ll need two copies for it</span>
  <span class="n">shr</span>    <span class="n">r13</span><span class="p">,</span> <span class="mi">6</span>                               <span class="c1"># We first get which 64 bit chunk of the bitstring we want to modify</span>
  <span class="ow">and</span>    <span class="n">rcx</span><span class="p">,</span> <span class="mi">63</span>                              <span class="c1"># Then the bit we want to change</span>
  <span class="n">mov</span>    <span class="n">rbp</span><span class="p">,</span> <span class="mi">1</span>                               <span class="c1"># Generate the mask we&#39;ll use to set the correct bit</span>
  <span class="n">shl</span>    <span class="n">rbp</span><span class="p">,</span> <span class="n">cl</span>
  <span class="c1"># We&#39;ll start with the right branch</span>
  <span class="ow">or</span>     <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">r13</span><span class="p">],</span> <span class="n">rbp</span>         <span class="c1"># Set the bit</span>
  <span class="n">inc</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="n">bitstr_len</span><span class="p">]</span>         <span class="c1"># Increase the bitstring length</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="n">tree_right</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">generate_codebook_recurse</span>
  <span class="c1"># Now we move on to the left branch: rbx - left child, r13 - bitstring index, rbp - mask</span>
  <span class="ow">not</span>    <span class="n">rbp</span>
  <span class="ow">and</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">r13</span><span class="p">],</span> <span class="n">rbp</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="n">tree_left</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">generate_codebook_recurse</span>
  <span class="n">dec</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="n">bitstr_len</span><span class="p">]</span>         <span class="c1"># Decrease the bitstring length</span>
<span class="n">generate_codebook_recurse_done</span><span class="p">:</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">pop</span>    <span class="n">rbp</span>
  <span class="n">ret</span>

<span class="c1"># rdi - text</span>
<span class="c1"># RET rax - Huffman-tree root (ptr)</span>
<span class="n">generate_tree</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">sub</span>    <span class="n">rsp</span><span class="p">,</span> <span class="mi">5128</span>                            <span class="c1"># 1024 bytes for the char counts, 4 bytes for heap length, 4096 bytes for the heap, 4 byte padding</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rdi</span>                             <span class="c1"># Save the original text so it doesn&#39;t get clobbered</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">rsp</span>                             <span class="c1"># Zero out the character counts and the heap length</span>
  <span class="n">xor</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">mov</span>    <span class="n">rdx</span><span class="p">,</span> <span class="mi">1040</span>
  <span class="n">call</span>   <span class="n">memset</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
<span class="n">generate_tree_count_chars</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">al</span><span class="p">,</span> <span class="n">BYTE</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span><span class="p">]</span>
  <span class="n">test</span>   <span class="n">al</span><span class="p">,</span> <span class="n">al</span>
  <span class="n">jz</span>     <span class="n">generate_tree_leaves_setup</span>
  <span class="n">inc</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">rax</span><span class="p">]</span>
  <span class="n">inc</span>    <span class="n">r12</span>
  <span class="n">jmp</span>    <span class="n">generate_tree_count_chars</span>
<span class="n">generate_tree_leaves_setup</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="mi">255</span>                             <span class="c1"># The loop counter. We can only get here if the &quot;test&quot; on line 301 resulted in a zero so the next jl instruction will do the right thing</span>
<span class="n">generate_tree_leaves</span><span class="p">:</span>
  <span class="n">jl</span>     <span class="n">generate_tree_branches</span>               <span class="c1"># If not then it&#39;s time to generate the branches</span>
  <span class="n">mov</span>    <span class="n">r13d</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">r12</span><span class="p">]</span>        <span class="c1"># Load the count at the ith position</span>
  <span class="n">test</span>   <span class="n">r13d</span><span class="p">,</span> <span class="n">r13d</span>                           <span class="c1"># And check if it&#39;s zero</span>
  <span class="n">jz</span>     <span class="n">generate_tree_leaves_counters</span>        <span class="c1"># If it is we can skip this iteration</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="mi">1</span>                               <span class="c1"># If not, we need to allocate a new leaf node</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">tree_size</span>
  <span class="n">call</span>   <span class="n">calloc</span>
  <span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="n">tree_value</span><span class="p">],</span> <span class="n">r12d</span>   <span class="c1"># Save the value and the count to the tree</span>
  <span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="n">tree_count</span><span class="p">],</span> <span class="n">r13d</span>
  <span class="n">lea</span>    <span class="n">rdi</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="n">counts_size</span><span class="p">]</span>             <span class="c1"># Then push it onto the heap</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">heap_push</span>
<span class="n">generate_tree_leaves_counters</span><span class="p">:</span>
  <span class="n">dec</span>    <span class="n">r12</span>                                  <span class="c1"># Decrement the loop counter and start over</span>
  <span class="n">jmp</span>    <span class="n">generate_tree_leaves</span>
<span class="n">generate_tree_branches</span><span class="p">:</span>
  <span class="nb">cmp</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="n">counts_size</span><span class="p">],</span> <span class="mi">1</span>     <span class="c1"># Check if there are still at least two elements in the heap</span>
  <span class="n">jle</span>    <span class="n">generate_tree_done</span>                   <span class="c1"># If not, we&#39;re done</span>
  <span class="n">lea</span>    <span class="n">rdi</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="n">counts_size</span><span class="p">]</span>             <span class="c1"># Get the left child</span>
  <span class="n">call</span>   <span class="n">heap_pop</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">lea</span>    <span class="n">rdi</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="n">counts_size</span><span class="p">]</span>             <span class="c1"># Get the right child</span>
  <span class="n">call</span>   <span class="n">heap_pop</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">tree_size</span>                       <span class="c1"># Create the new tree node, the pointer to it will be in rax</span>
  <span class="n">call</span>   <span class="n">malloc</span>
  <span class="n">mov</span>    <span class="n">ecx</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="n">tree_count</span><span class="p">]</span>    <span class="c1"># The new node&#39;s count: left count + right count</span>
  <span class="n">add</span>    <span class="n">ecx</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r13</span> <span class="o">+</span> <span class="n">tree_count</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="n">tree_left</span><span class="p">],</span> <span class="n">r12</span>     <span class="c1"># Save the new node&#39;s fields: left, right, count (leave value unititialized, it shouldn&#39;t be used with branch nodes)</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="n">tree_right</span><span class="p">],</span> <span class="n">r13</span>
  <span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="n">tree_count</span><span class="p">],</span> <span class="n">ecx</span>
  <span class="n">lea</span>    <span class="n">rdi</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="n">counts_size</span><span class="p">]</span>             <span class="c1"># Add the branch to the heap</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">heap_push</span>
  <span class="n">jmp</span>    <span class="n">generate_tree_branches</span>
<span class="n">generate_tree_done</span><span class="p">:</span>
  <span class="n">lea</span>    <span class="n">rdi</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="n">counts_size</span><span class="p">]</span>             <span class="c1"># The tree&#39;s root will be in rax after the pop</span>
  <span class="n">call</span>   <span class="n">heap_pop</span>
  <span class="n">add</span>    <span class="n">rsp</span><span class="p">,</span> <span class="mi">5128</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>

<span class="c1"># rdi - heap ptr</span>
<span class="c1"># rsi - tree ptr</span>
<span class="n">heap_push</span><span class="p">:</span>
  <span class="n">lea</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="n">heap_data</span><span class="p">]</span>     <span class="c1"># We load the heap&#39;s data ptr and length to the respective registers</span>
  <span class="n">mov</span>    <span class="n">ecx</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="n">heap_len</span><span class="p">]</span>      <span class="c1"># Load the current length</span>
  <span class="n">lea</span>    <span class="n">edx</span><span class="p">,</span> <span class="p">[</span><span class="n">ecx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>                       <span class="c1"># First, calculate the new length (length + 1)</span>
  <span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="n">heap_len</span><span class="p">],</span> <span class="n">edx</span>      <span class="c1"># Then save it</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">rcx</span><span class="p">],</span> <span class="n">rsi</span>         <span class="c1"># And finally add the new value at the end of the array</span>
<span class="n">heap_push_sift_up</span><span class="p">:</span>
  <span class="n">test</span>   <span class="n">rcx</span><span class="p">,</span> <span class="n">rcx</span>                             <span class="c1"># Test if we got to the root (index == 0)</span>
  <span class="n">jz</span>     <span class="n">heap_push_done</span>
  <span class="n">lea</span>    <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rcx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>                       <span class="c1"># Calculate the parent index: (index - 1) / 2</span>
  <span class="n">shr</span>    <span class="n">rdx</span><span class="p">,</span> <span class="mi">1</span>
  <span class="n">lea</span>    <span class="n">r8</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">rcx</span><span class="p">]</span>                    <span class="c1"># Get the pointer to the current and parent elements</span>
  <span class="n">lea</span>    <span class="n">r9</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">rdx</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">r10</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r8</span><span class="p">]</span>                  <span class="c1"># Load the current and the parent elements</span>
  <span class="n">mov</span>    <span class="n">r11</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r9</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">esi</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r10</span> <span class="o">+</span> <span class="n">tree_count</span><span class="p">]</span>    <span class="c1"># Load the current tree&#39;s count</span>
  <span class="nb">cmp</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r11</span> <span class="o">+</span> <span class="n">tree_count</span><span class="p">],</span> <span class="n">esi</span>    <span class="c1"># If parent count &lt;= current count</span>
  <span class="n">jle</span>    <span class="n">heap_push_done</span>                       <span class="c1"># Then we&#39;re done</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r8</span><span class="p">],</span> <span class="n">r11</span>                  <span class="c1"># Otherwise swap the two elements</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r9</span><span class="p">],</span> <span class="n">r10</span>
  <span class="n">mov</span>    <span class="n">rcx</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">jmp</span>    <span class="n">heap_push_sift_up</span>
<span class="n">heap_push_done</span><span class="p">:</span>
  <span class="n">ret</span>

<span class="c1"># rdi - heap ptr</span>
<span class="c1"># RET rax - tree ptr</span>
<span class="n">heap_pop</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">r8d</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="n">heap_len</span><span class="p">]</span>      <span class="c1"># Load the heap&#39;s length</span>
  <span class="n">test</span>   <span class="n">r8d</span><span class="p">,</span> <span class="n">r8d</span>                             <span class="c1"># If it&#39;s 0 then the heap&#39;s empty</span>
  <span class="n">jz</span>     <span class="n">heap_empty</span>
  <span class="n">lea</span>    <span class="n">rdx</span><span class="p">,</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="n">heap_data</span><span class="p">]</span>               <span class="c1"># Get the heap&#39;s data ptr</span>
  <span class="n">mov</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span><span class="p">]</span>                 <span class="c1"># The return value will be the tree&#39;s current root</span>
  <span class="n">lea</span>    <span class="n">r8d</span><span class="p">,</span> <span class="p">[</span><span class="n">r8d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>                       <span class="c1"># Calculate the new length</span>
  <span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="n">heap_len</span><span class="p">],</span> <span class="n">r8d</span>      <span class="c1"># And save it</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">r8</span><span class="p">]</span>          <span class="c1"># Load the element we&#39;re going to swap with the root</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span><span class="p">],</span> <span class="n">rsi</span>                 <span class="c1"># Swap the root and the last element</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">r8</span><span class="p">],</span> <span class="n">rax</span>
  <span class="n">xor</span>    <span class="n">r9</span><span class="p">,</span> <span class="n">r9</span>                               <span class="c1"># The loop index</span>
<span class="n">heap_pop_sift_down</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rcx</span><span class="p">,</span> <span class="n">r9</span>                              <span class="c1"># Save the target index at the start of the loop</span>
  <span class="n">lea</span>    <span class="n">r10</span><span class="p">,</span> <span class="p">[</span><span class="n">r9</span> <span class="o">+</span> <span class="n">r9</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>                   <span class="c1"># The left child index</span>
  <span class="n">lea</span>    <span class="n">r11</span><span class="p">,</span> <span class="p">[</span><span class="n">r9</span> <span class="o">+</span> <span class="n">r9</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>                   <span class="c1"># The right child index</span>
  <span class="nb">cmp</span>    <span class="n">r10</span><span class="p">,</span> <span class="n">r8</span>
  <span class="n">jge</span>    <span class="n">heap_pop_check_right</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">r10</span><span class="p">]</span>         <span class="c1"># Load the left child</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">rcx</span><span class="p">]</span>         <span class="c1"># Load the target</span>
  <span class="n">mov</span>    <span class="n">esi</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rsi</span> <span class="o">+</span> <span class="n">tree_count</span><span class="p">]</span>    <span class="c1"># Load the target tree count</span>
  <span class="nb">cmp</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="n">tree_count</span><span class="p">],</span> <span class="n">esi</span>    <span class="c1"># If the left tree count &lt; target tree count</span>
  <span class="n">jge</span>    <span class="n">heap_pop_check_right</span>
  <span class="n">mov</span>    <span class="n">rcx</span><span class="p">,</span> <span class="n">r10</span>
<span class="n">heap_pop_check_right</span><span class="p">:</span>
  <span class="nb">cmp</span>    <span class="n">r11</span><span class="p">,</span> <span class="n">r8</span>
  <span class="n">jge</span>    <span class="n">heap_pop_compare_indices</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">r11</span><span class="p">]</span>         <span class="c1"># Load the right child</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">rcx</span><span class="p">]</span>         <span class="c1"># Load the target</span>
  <span class="n">mov</span>    <span class="n">esi</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rsi</span> <span class="o">+</span> <span class="n">tree_count</span><span class="p">]</span>    <span class="c1"># Load the target tree count</span>
  <span class="nb">cmp</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="n">tree_count</span><span class="p">],</span> <span class="n">esi</span>    <span class="c1"># If the right tree count &lt; target tree count</span>
  <span class="n">jge</span>    <span class="n">heap_pop_compare_indices</span>
  <span class="n">mov</span>    <span class="n">rcx</span><span class="p">,</span> <span class="n">r11</span>
<span class="n">heap_pop_compare_indices</span><span class="p">:</span>
  <span class="nb">cmp</span>    <span class="n">r9</span><span class="p">,</span> <span class="n">rcx</span>                              <span class="c1"># If the target index == current index we&#39;re done</span>
  <span class="n">je</span>     <span class="n">heap_pop_done</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">r9</span><span class="p">]</span>          <span class="c1"># Otherwise we swap the values</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">rcx</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">r9</span><span class="p">],</span> <span class="n">rsi</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">rcx</span><span class="p">],</span> <span class="n">rdi</span>
  <span class="n">mov</span>    <span class="n">r9</span><span class="p">,</span> <span class="n">rcx</span>
  <span class="n">jmp</span>    <span class="n">heap_pop_sift_down</span>
<span class="n">heap_empty</span><span class="p">:</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>                             <span class="c1"># Return a null pointer to indicate the heap was empty</span>
<span class="n">heap_pop_done</span><span class="p">:</span>
  <span class="n">ret</span>

<span class="c1"># rdi - codebook start ptr</span>
<span class="n">print_codebook</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">rbx</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">sub</span>    <span class="n">rsp</span><span class="p">,</span> <span class="mi">272</span>                             <span class="c1"># The bitstring we&#39;re going to print</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">xor</span>    <span class="n">rbx</span><span class="p">,</span> <span class="n">rbx</span>                             <span class="c1"># Save the loop counter into a register that doesn&#39;t get clobbered</span>
<span class="n">print_codebook_loop</span><span class="p">:</span>
  <span class="nb">cmp</span>    <span class="n">rbx</span><span class="p">,</span> <span class="mi">255</span>
  <span class="n">jg</span>     <span class="n">print_codebook_done</span>
  <span class="n">lea</span>    <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rbx</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">rbx</span><span class="p">]</span>                   <span class="c1"># We get the codebook entry at the specific index</span>
  <span class="n">lea</span>    <span class="n">r10</span><span class="p">,</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">rax</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">rdx</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r10</span> <span class="o">+</span> <span class="n">bitstr_len</span><span class="p">]</span>    <span class="c1"># Load the length of the bitstring</span>
  <span class="n">test</span>   <span class="n">rdx</span><span class="p">,</span> <span class="n">rdx</span>                             <span class="c1"># If it&#39;s zero then the codepoint didn&#39;t exist in the original alphabet, skip</span>
  <span class="n">jz</span>     <span class="n">print_codebook_counters</span>
<span class="n">print_codebook_char</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">BYTE</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rsp</span><span class="p">],</span> <span class="n">bl</span>                   <span class="c1"># First, the character we&#39;re printing the code for</span>
  <span class="n">mov</span>    <span class="n">WORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="mh">0x203a</span>           <span class="c1"># Then &quot;: &quot;</span>
  <span class="n">mov</span>    <span class="n">BYTE</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="n">rdx</span> <span class="o">+</span> <span class="mi">3</span><span class="p">],</span> <span class="mh">0x00</span>       <span class="c1"># At the end add the null terminator</span>
<span class="n">print_codebook_generate_binary</span><span class="p">:</span>
  <span class="n">dec</span>    <span class="n">rdx</span>
  <span class="n">jl</span>     <span class="n">print_codebook_binary</span>
  <span class="n">mov</span>    <span class="n">r9</span><span class="p">,</span> <span class="n">rdx</span>                              <span class="c1"># Two copies of the loop counter</span>
  <span class="n">mov</span>    <span class="n">rcx</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">shr</span>    <span class="n">r9</span><span class="p">,</span> <span class="mi">6</span>                                <span class="c1"># Calculate the bitstring part we&#39;re going to load</span>
  <span class="ow">and</span>    <span class="n">rcx</span><span class="p">,</span> <span class="mi">63</span>                              <span class="c1"># The bit we&#39;re interested in</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r10</span> <span class="o">+</span> <span class="n">r9</span><span class="p">]</span>            <span class="c1"># One of the 4, 64 bit parts of the bitstring we&#39;re going to print</span>
  <span class="n">shr</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">cl</span>                              <span class="c1"># Get the relevant bit into the 0th position</span>
  <span class="ow">and</span>    <span class="n">rsi</span><span class="p">,</span> <span class="mi">1</span>                               <span class="c1"># Mask the rest of the bits</span>
  <span class="n">add</span>    <span class="n">rsi</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span>                             <span class="c1"># Convert it to ASCII</span>
  <span class="n">mov</span>    <span class="n">BYTE</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rsp</span> <span class="o">+</span> <span class="n">rdx</span> <span class="o">+</span> <span class="mi">3</span><span class="p">],</span> <span class="n">sil</span>        <span class="c1"># And copy it into the string</span>
  <span class="n">jmp</span>    <span class="n">print_codebook_generate_binary</span>
<span class="n">print_codebook_binary</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">rsp</span>                             <span class="c1"># Print the current bitstring</span>
  <span class="n">call</span>   <span class="n">puts</span>
<span class="n">print_codebook_counters</span><span class="p">:</span>
  <span class="n">inc</span>    <span class="n">rbx</span>                                  <span class="c1"># And go to the next codebook entry</span>
  <span class="n">jmp</span>    <span class="n">print_codebook_loop</span>
<span class="n">print_codebook_done</span><span class="p">:</span>
  <span class="n">add</span>    <span class="n">rsp</span><span class="p">,</span> <span class="mi">272</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">pop</span>    <span class="n">rbx</span>
  <span class="n">ret</span>

<span class="c1"># rdi - message ptr</span>
<span class="c1"># This would run out of stack space for long messages but it will do for now</span>
<span class="n">print_message</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="p">]</span>                 <span class="c1"># Get the length of the message</span>
  <span class="n">lea</span>    <span class="n">rdi</span><span class="p">,</span> <span class="p">[</span><span class="n">r13</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>                       <span class="c1"># For the length of the string we&#39;ll need an additional the null terminator</span>
  <span class="n">call</span>   <span class="n">malloc</span>
  <span class="n">xor</span>    <span class="n">rdx</span><span class="p">,</span> <span class="n">rdx</span>
<span class="n">print_message_generate_string</span><span class="p">:</span>
  <span class="nb">cmp</span>    <span class="n">rdx</span><span class="p">,</span> <span class="n">r13</span>
  <span class="n">jge</span>    <span class="n">print_message_puts</span>
  <span class="n">mov</span>    <span class="n">r8</span><span class="p">,</span> <span class="n">rdx</span>                              <span class="c1"># Get two copies of the current index</span>
  <span class="n">mov</span>    <span class="n">rcx</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">shr</span>    <span class="n">r8</span><span class="p">,</span> <span class="mi">3</span>                                <span class="c1"># We first get the byte we want to print</span>
  <span class="n">mov</span>    <span class="n">r10b</span><span class="p">,</span> <span class="n">BYTE</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="n">r8</span> <span class="o">+</span> <span class="n">msg_data</span><span class="p">]</span>
  <span class="ow">and</span>    <span class="n">rcx</span><span class="p">,</span> <span class="mi">7</span>                               <span class="c1"># Then the bit in that byte</span>
  <span class="n">shr</span>    <span class="n">r10</span><span class="p">,</span> <span class="n">cl</span>
  <span class="ow">and</span>    <span class="n">r10</span><span class="p">,</span> <span class="mh">0x1</span>                             <span class="c1"># Mask it so only the bit we&#39;re interested in is visible</span>
  <span class="n">add</span>    <span class="n">r10</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span>                             <span class="c1"># Convert it to ASCII</span>
  <span class="n">mov</span>    <span class="n">BYTE</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="n">rdx</span><span class="p">],</span> <span class="n">r10b</span>           <span class="c1"># Write it into the printable string</span>
  <span class="n">inc</span>    <span class="n">rdx</span>
  <span class="n">jmp</span>    <span class="n">print_message_generate_string</span>
<span class="n">print_message_puts</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">BYTE</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="n">rdx</span><span class="p">],</span> <span class="mh">0x00</span>           <span class="c1"># Write the null terminator</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">rax</span>                             <span class="c1"># And print the string</span>
  <span class="n">call</span>   <span class="n">puts</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>

<span class="c1"># rdi - tree ptr</span>
<span class="n">free_tree</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">rbx</span>
  <span class="n">mov</span>    <span class="n">rbx</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">test</span>   <span class="n">rbx</span><span class="p">,</span> <span class="n">rbx</span>                             <span class="c1"># When the tree ptr we&#39;re trying to free is already null we reached the termination condition</span>
  <span class="n">jz</span>     <span class="n">free_tree_done</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="p">[</span><span class="n">rbx</span> <span class="o">+</span> <span class="n">tree_left</span><span class="p">]</span>               <span class="c1"># Otherwise free the left child first</span>
  <span class="n">call</span>   <span class="n">free_tree</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="p">[</span><span class="n">rbx</span> <span class="o">+</span> <span class="n">tree_right</span><span class="p">]</span>              <span class="c1"># Then the right child</span>
  <span class="n">call</span>   <span class="n">free_tree</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">rbx</span>                             <span class="c1"># And finally, the node itself</span>
  <span class="n">call</span>   <span class="n">free</span>
<span class="n">free_tree_done</span><span class="p">:</span>
  <span class="n">pop</span>    <span class="n">rbx</span>
  <span class="n">ret</span>
</pre></div>

</div></p>
</div><div class="scala">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scala.collection.mutable.</span><span class="p">{</span><span class="n">Map</span><span class="p">,</span> <span class="n">PriorityQueue</span><span class="p">}</span>

<span class="nb">object</span> <span class="n">HuffmanEncoding</span> <span class="p">{</span>

  <span class="n">trait</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Int</span>
  <span class="p">}</span>

  <span class="n">case</span> <span class="k">class</span> <span class="nc">Leaf</span><span class="p">(</span><span class="n">char</span><span class="p">:</span> <span class="n">Char</span><span class="p">,</span> <span class="n">var</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="n">extends</span> <span class="n">Node</span>

  <span class="n">case</span> <span class="k">class</span> <span class="nc">Branch</span><span class="p">(</span><span class="n">left</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">var</span> <span class="n">weight</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="n">extends</span> <span class="n">Node</span>

  <span class="k">def</span> <span class="nf">createTree</span><span class="p">(</span><span class="n">phrase</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Option</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>

    <span class="n">val</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">[</span><span class="n">Node</span><span class="p">]()(</span><span class="n">Ordering</span><span class="o">.</span><span class="n">by</span><span class="p">(</span><span class="o">-</span><span class="n">_</span><span class="o">.</span><span class="n">weight</span><span class="p">))</span>
    <span class="n">tree</span> <span class="o">++=</span> <span class="n">phrase</span>
      <span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="n">identity</span><span class="p">)</span>
      <span class="o">.</span><span class="n">mapValues</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
      <span class="o">.</span><span class="n">map</span><span class="p">{</span>
        <span class="n">case</span> <span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">Leaf</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
      <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">val</span> <span class="n">node1</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">dequeue</span><span class="p">()</span>
      <span class="n">val</span> <span class="n">node2</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">dequeue</span><span class="p">()</span>
      <span class="n">tree</span> <span class="o">+=</span> <span class="n">Branch</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">node1</span><span class="o">.</span><span class="n">weight</span> <span class="o">+</span> <span class="n">node2</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">tree</span><span class="o">.</span><span class="n">headOption</span>
  <span class="p">}</span>


  <span class="k">def</span> <span class="nf">createCodeBook</span><span class="p">(</span><span class="n">maybeRoot</span><span class="p">:</span> <span class="n">Option</span><span class="p">[</span><span class="n">Node</span><span class="p">]):</span> <span class="n">Map</span><span class="p">[</span><span class="n">Char</span><span class="p">,</span> <span class="n">String</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">val</span> <span class="n">codeBook</span> <span class="o">=</span> <span class="n">Map</span><span class="p">[</span><span class="n">Char</span><span class="p">,</span> <span class="n">String</span><span class="p">]()</span>

    <span class="k">def</span> <span class="nf">codeBookRecurse</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Unit</span> <span class="o">=</span>
      <span class="n">node</span> <span class="n">match</span> <span class="p">{</span>
        <span class="n">case</span> <span class="n">Leaf</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">codeBook</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span>
        <span class="n">case</span> <span class="n">Branch</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="n">codeBookRecurse</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">code</span> <span class="o">+</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>
          <span class="n">codeBookRecurse</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">code</span> <span class="o">+</span> <span class="s2">&quot;1&quot;</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>

    <span class="n">maybeRoot</span><span class="o">.</span><span class="n">foreach</span><span class="p">(</span><span class="n">c</span> <span class="o">=&gt;</span> <span class="n">codeBookRecurse</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>

    <span class="n">codeBook</span>
  <span class="p">}</span>


  <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="n">phrase</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">codeBook</span><span class="p">:</span> <span class="n">Map</span><span class="p">[</span><span class="n">Char</span><span class="p">,</span> <span class="n">String</span><span class="p">]):</span> <span class="n">String</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">phrase</span><span class="o">.</span><span class="n">flatMap</span><span class="p">(</span><span class="n">c</span> <span class="o">=&gt;</span> <span class="n">codeBook</span><span class="o">.</span><span class="n">getOrElse</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s2">&quot;?&quot;</span><span class="p">))</span>
  <span class="p">}</span>

  <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="n">encoded</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">maybeRoot</span><span class="p">:</span> <span class="n">Option</span><span class="p">[</span><span class="n">Node</span><span class="p">]):</span> <span class="n">String</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">val</span> <span class="n">root</span> <span class="o">=</span> <span class="n">maybeRoot</span><span class="o">.</span><span class="n">getOrElse</span><span class="p">(</span><span class="n">Leaf</span><span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">var</span> <span class="n">currentNode</span> <span class="o">=</span> <span class="n">root</span>

    <span class="k">def</span> <span class="nf">chooseTreeBranch</span><span class="p">(</span><span class="n">bit</span><span class="p">:</span> <span class="n">Char</span><span class="p">)</span> <span class="o">=</span>
      <span class="n">currentNode</span> <span class="n">match</span> <span class="p">{</span>
        <span class="n">case</span> <span class="n">Branch</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=&gt;</span>
          <span class="n">currentNode</span> <span class="o">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="n">left</span> <span class="k">else</span> <span class="n">right</span>
        <span class="n">case</span> <span class="n">_</span> <span class="o">=&gt;</span>
      <span class="p">}</span>

    <span class="k">def</span> <span class="nf">maybeGetACharacter</span> <span class="o">=</span>
      <span class="n">currentNode</span> <span class="n">match</span> <span class="p">{</span>
        <span class="n">case</span> <span class="n">Leaf</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="n">currentNode</span> <span class="o">=</span> <span class="n">root</span>
          <span class="n">Some</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">case</span> <span class="n">_</span> <span class="o">=&gt;</span> <span class="kc">None</span>
      <span class="p">}</span>

    <span class="n">encoded</span>
      <span class="o">.</span><span class="n">flatMap</span><span class="p">(</span><span class="n">bit</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="n">chooseTreeBranch</span><span class="p">(</span><span class="n">bit</span><span class="p">)</span>
        <span class="n">maybeGetACharacter</span>
      <span class="p">})</span>
  <span class="p">}</span>

  <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">String</span><span class="p">]):</span> <span class="n">Unit</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">val</span> <span class="n">originalText</span> <span class="o">=</span> <span class="s2">&quot;bibbity_bobbity&quot;</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">&quot;Original Text: &quot;</span> <span class="o">+</span> <span class="n">originalText</span><span class="p">)</span>

    <span class="n">val</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">createTree</span><span class="p">(</span><span class="n">originalText</span><span class="p">)</span>
    <span class="n">val</span> <span class="n">codeBook</span> <span class="o">=</span> <span class="n">createCodeBook</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">&quot;CodeBook is: &quot;</span> <span class="o">+</span> <span class="n">codeBook</span><span class="p">)</span>

    <span class="n">val</span> <span class="n">encoded</span> <span class="o">=</span> <span class="n">encode</span><span class="p">(</span><span class="n">originalText</span><span class="p">,</span> <span class="n">codeBook</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">&quot;Encoded text: &quot;</span> <span class="o">+</span> <span class="n">encoded</span><span class="p">)</span>

    <span class="n">val</span> <span class="n">decoded</span> <span class="o">=</span> <span class="n">decode</span><span class="p">(</span><span class="n">encoded</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">&quot;Decoded text: &quot;</span> <span class="o">+</span> <span class="n">decoded</span><span class="p">)</span>

  <span class="p">}</span>

<span class="p">}</span>
</pre></div>

</div></p>
</div>
</div>

<script>
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
</script>

<h2>License</h2>
<h5>Code Examples</h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5>Text</h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5>Images/Graphics</h5>
<ul>
<li>The image "<a href="res/huffman_tree.png">huffman_tree</a>" was created by <a href="https://github.com/julianschacher">Julian Schacher</a> and is licenced under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<h5>Pull Requests</h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:
- none</p>
        <hr>
    </div>
</body>
</html>